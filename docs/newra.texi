@c -*-texinfo-*-
@c %**start of header
@setfilename newra.info
@documentencoding UTF-8
@settitle newra —An array library for Guile 3
@c %**end of header
@c last [ma112]

@set VERSION 1
@set UPDATED 2019 November 11

@copying
@code{newra} (version @value{VERSION}, updated @value{UPDATED})

(c) lloda 2017--2019

@smalldisplay
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
@end smalldisplay
@end copying

@dircategory Guile libraries
@direntry
* newra: (newra.info).  Array library for Guile meant to replace the built-in array facility.
@end direntry

@include my-bib-macros.texi
@mybibuselist{Sources}

@titlepage
@title newra
@subtitle version @value{VERSION}, updated @value{UPDATED}
@author lloda
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@ifnottex
@node Top
@top @code{newra}

@insertcopying

@code{newra} is a Scheme-only replacement for the built-in C-based array facility in Guile 2.2.

@menu
* Overview::          Why Guile arrays need replacing.
* Basics::            Using arrays as containers.
* Advanced usage::    Guile as an array language.
* Hazards::           User beware.
* Reference::         Systematic list of types and functions.
* @mybibnode{}::      It's been done before.
* Indices::           Or try the search function.
@end menu

@end ifnottex

@iftex
@shortcontents
@end iftex

@c ------------------------------------------------
@node Overview
@chapter Overview
@c ------------------------------------------------

An array is an aggregate of the following pieces:

@cindex rank
@cindex dim vector
@cindex root vector
@itemize
@item A @dfn{root vector}.
This can be a Scheme vector, as well as one of several other vector-like types.
@item A @dfn{zero}.
An arbitary integer.
@item A @dfn{dim vector}.
Each dim consists of a length (@dfn{len}), a lower bound (@dfn{lo}), and a @dfn{step}. The length of the dim vector is the @dfn{rank} of the array.
@end itemize

Together, the dim vector and the zero define an affine function of array indices @code{i₀, i₁, ..} that produces an index into the root vector (or root for short). Thus, the array is simply a multidimensional view of the root.

For example, the following pieces

@itemize
@item root: v = @code{#(1 2 3 4 5 6 7)}
@item zero: 1
@item dims: @code{#(#<<dim> len: 2 lo: 0 step: 2> #<<dim> len: 2 lo: 0 step: 1>)}
@end itemize

define an array A(i₀, i₁) = v(1 + 2·i₀ + 1·i₁), 0≤i₀<2, 0≤i₁<2, that is A = [[2 3] [4 5]].

In @code{newra} code,

@example @c [ma106]
@verbatim
(make-ra-root (vector 1 2 3 4 5 6 7) 1 (vector (make-dim 2 0 2) (make-dim 2 0 1)))
@end verbatim
@result{} @code{#%2:2:2((2 3) (4 5))}
@end example

The default print style means @code{#%RANK:LEN₀:LEN₁(...)}.

It's unusual to need to specify the dims directly. More commonly, one creates an array of whatever size

@verbatim
> (define a (make-ra #f 3 4))
> a
@end verbatim
@result{} @code{#%2:3:4((#f #f #f #f) (#f #f #f #f) (#f #f #f #f))}

which automatically creates a root of the required size, so that all the array elements are distinct. Then one operates on the array without making reference to the underlying root,

@verbatim
> (ra-set! a 99 2 2)
@end verbatim
@result{} @code{#%2:3:4((#f #f #f #f) (#f #f 99 #f) (#f #f #f #f))}

Still, since the array is just a view of the root, any changes on the array are reflected there as well

@verbatim
> (ra-root a)
@end verbatim
@result{} @code{#(#f #f #f #f #f #f #f #f #f #f 99 #f)}

and the other way around,

@verbatim
> (define b (make-ra-root (vector 'x) 0 (vector (make-dim 3 0 0) (make-dim 2 0 0))))
> b
@end verbatim
@result{} @code{#%2:3:2((x x) (x x) (x x))}

@verbatim
> (vector-set! (ra-root b) 0 'Z)
> b
@end verbatim
@result{} @code{#%2:3:2((Z Z) (Z Z) (Z Z))}

@emph{expressions} @dfn{matrices}

@verbatim
A = B+C;
@end verbatim

@cindex Guile
Text to be written

@menu
* Built-in Guile arrays::
@end menu

@c ------------------------------------------------
@node Built-in Guile arrays
@section Built-in Guile arrays
@c ------------------------------------------------

Dense multidimensional arrays work similarly in every language that offers them, and built-in Guile arrays are no different —they also have a root (@code{shared-array-root}), a zero (computable from @code{shared-array-offset}), and a dim vector (@code{array-shape}, @code{shared-array-increments}). Functionally, they are entirely equivalent to the objects offered by @code{newra}. Why replace them, then?

@cindex libguile
Built-in Guile arrays are implemented in C, as part of libguile. As a Guile type they have their own low-level type tag, and all the basic array operations are C stubs, even the most basic functions such as @code{array-ref} or @code{array-rank}. Obtaining any of the components of the array requires calling into C. There are several problems with this.

First, the built-in library offers a single function to manipulate array dims, @code{make-shared-array}. Although this is a sufficient interface, it is excessively generic, and also very cumbersome and inefficient. The array dims cannot be manipulated directly from Scheme, so any alternative interface written in Scheme is forced to go through @code{make-shared-array}.

Second, the C stubs create a barrier to optimization by the Scheme compiler. The main loop of an operation such as @code{(array-map! c + a b)} has to be implemented in C (for the reasons given above) and then it has to call back to Scheme on each iteration in order to apply @code{+}. Since the Scheme compiler doesn't have any special support for @code{array-map!}, it doesn't know what the types of the arguments are, etc. and those checks and dispatches are repeated over and over. @footnote{Guile used to offer dedicated operations to sum arrays, etc. but obviously that isn't any kind of solution.}

Third, the larger functions of the array interface, such as @code{array-map!}, etc. are not interruptible. This is especially inconvenient when operating on large arrays.

These problems are solved if the built-in type is replaced with a new type defined in Scheme.

@anchor{x-star}
FIXME (see @ref{x-star,@code{star}})

@c ------------------------------------------------
@node Basics
@chapter Basics
@c ------------------------------------------------

@menu
* Creating arrays::
* Special arrays::
* Iteration::
* Slicing::
* Reshaping and resizing::
* Other operations on arrays::
* Compatibility with old Guile arrays::
@end menu

@c ------------------------------------------------
@node Creating arrays
@section Creating arrays
@c ------------------------------------------------

An array can be created anew (@ref{x-make-ra-new, make-ra-new}), or over an existing root (@ref{x-make-ra-root, make-ra-root}). @ref{x-c-dims, c-dims} can be used to compute the dim vector.

@example
@verbatim
(make-ra-new #t 'x (vector (make-dim 3 0 2) (make-dim 2 0 1))) ; more simply
(make-ra-new #t 'x (c-dims 3 2))
@end verbatim
@result{} #%2:3:2((x x) (x x) (x x))
@end example

@example
@verbatim
(make-ra-new 'f32 0.0 (c-dims 3 2))
@end verbatim
@result{} #%2f32:3:2((0.0 0.0) (0.0 0.0) (0.0 0.0))
@end example

An existing root implies the type, so it doesn't need to be given.

@example
@verbatim
(make-ra-root (vector 1 2 3 4 5 6) (c-dims 3 2))
@end verbatim
@result{} #%2:3:2((1 2) (3 4) (5 6))
@end example

@ref{x-make-ra, make-ra} or @ref{x-make-typed-ra, make-typed-ra} use @code{c-dims} by default.

@example
@verbatim
(make-ra 99 2 3)
@end verbatim
@result{} #%2:3:2((9 9) (9 9) (9 9))
@end example

@example
@verbatim
(make-typed-ra 'f64 99 2 3)
@end verbatim
@result{} #%2f64:3:2((9.0 9.0) (9.0 9.0) (9.0 9.0))
@end example

@c ------------------------------------------------
@node Special arrays
@section Special arrays
@c ------------------------------------------------

Any type that is usable as the root of an old built-in Guile array is also usable as root of a @code{newra} array. These include

@itemize
@item vectors (e.g. @code{(vector 3)})
@item SRFI-4 typed vectors (e.g. @code{(c64vector 1 2+0i)})
@item strings (e.g. @code{"hello"})
@item bitvectors (e.g. @code{(bitvector #f #t #f #t)})
@end itemize

@code{newra} supports an additional root vector type, @code{<aseq>}, representing an infinite arithmetic sequence.

@cindex @code{make-aseq}
@anchor{x-none}
@deffn @w{function} make-aseq [org [inc]]

Create an arithmetic sequence [@code{org, org+inc, org+2·inc, ...}]. The default values of @code{org} and @code{inc} are respectively 0 and 1. For example:

@example
@verbatim
(make-ra-root (make-aseq 0 3) (vector (make-dim 10)) 0)
@end verbatim
@result{} #%1d:10(0 3 6 9 12 15 18 21 24 27)
@end example

(The example above can be written @code{(@ref{x-ra-iota, ra-iota} 10 0 3)}).
@end deffn

@code{aseq} roots are immutable. The type tag of @code{aseq} roots is @code{d}. Arrays with integer-valued @code{aseq} roots have special uses; see @ref{Slicing}.

@cindex infinite axes
To make @code{<aseq>} more useful, @code{newra} supports axes with infinite length.

@example
@verbatim
(ra-ref (make-ra-root (make-aseq) (vector (make-dim #f)) 0) #e1e12) ; or more simply
(ra-ref (ra-iota #f) #e1e12)
@end verbatim
@result{} 1000000000000
@end example

These are treated especially when used in iteration, in that they match axes of any finite length (@ref{x-ra-map!, ra-map!}). Effectively this lets one use @code{(@ref{x-ra-transpose, ra-transpose} (ra-iota #f) k)} as a placeholder for the index over axis @code{k}.

@example
@verbatim
(ra-map! (make-ra 0 3) + (ra-iota 3) (ra-iota #f))
@end verbatim
@result{} #1%3(0 2 4)
@end example

@cindex dead axes
@code{newra} also supports `dead axes', which are simply axes whose step is 0. These axes can have any length although effectively only one position (the lower bound, by default 0) is ever accessed. Some functions work purely by creating dead axes.

@example
@verbatim
(define A (make-ra-root #(1 2 3) (c-dims 3)))
(ra-tile A 2 2)
@end verbatim
@result{} #%3d:2:2:3(((0 1 2) (0 1 2)) ((0 1 2) (0 1 2)))
@verbatim
(ra-dims (ra-tile A 2 2))
@end verbatim
@result{} #(#<<dim> len: 2 lo: 0 step: 0> #<<dim> len: 2 lo: 0 step: 0> #<<dim> len: 3 lo: 0 step: 1>)
@end example

@cindex singleton axis
When an axis has 0 step and infinite length, it operates essentially as ‘singleton axes’ operate in other array languages. The main diference is that the ability to match any finite length is explicit; an axis with length 1 will still fail to match an axis with length 2.

@c ------------------------------------------------
@node Iteration
@section Iteration
@c ------------------------------------------------

The basic array iteration operations in @code{newra} all operate by effect. This gives you control of how the result is allocated. If one of the arguments is designated as destination, then that is the result of the whole iteration. For example:

@example
@verbatim
(ra-map! (make-ra #f 3) - (ra-iota 3 1))
@end verbatim
@result{} #%1:3(-1 -2 -3)
@end example

It is common to need the indices of the elements during array iteration. @code{newra} iteration operations do not keep track of those indices@footnote{Except for @ref{x-ra-index-map!, ra-index-map!}, which is provided out of compatibility with the older array system.} because it isn't free to do so. You need to pass the indices you need as arguments, but it's easy to do so by using an infinite index vector together with @ref{x-ra-transpose, ra-transpose}.

@example
@verbatim
(define i0 (ra-iota #f))
(define i1 (ra-transpose (ra-iota #f) 1))
(ra-map! (make-ra #f 2 2) list (list->ra 2 '((A B) (C D))) i0 i1)
@end verbatim
@result{} #%2:2:2(((A 0 0) (B 0 1)) ((C 1 0) (D 1 1)))
@end example

One can iterate not only over the elements of the array, but over any @code{n}-frame (the first @code{n} axes of an array), using @ref{x-ra-slice-for-each, ra-slice-for-each}. In this case the operation takes array slices as arguments, even when they are rank 0; this allows writing to any of the arguments. When there are several arrays involved, all the frames must match.

@example
@verbatim
(ra-slice-for-each 1
  (lambda (xy angle)
    (ra-set! angle (atan (ra-ref xy 1) (ra-ref xy 0))))
  xys angles)
@end verbatim
@end example

@c ------------------------------------------------
@node Slicing
@section Slicing
@c ------------------------------------------------

@c ------------------------------------------------
@node Reshaping and resizing
@section Reshaping and resizing
@c ------------------------------------------------

@cindex APL
@cindex ρ
To match APL ρ, @code{newra} offers a set of three different functions.

@ref{x-ra-reshape, @code{ra-reshape}} and @ref{x-ra-ravel, @code{ra-ravel}} are in a way the inverse of each other, and neither is able to increase the size of the array. For that purpose @ref{x-ra-tile, @code{ra-tile}} is provided.

@code{ra-reshape} and @code{ra-tile} always reuse the root of the argument. On the other hand @code{ra-ravel} may not be able to — this is one of the reasons to have three different functions instead of only one.

All three functions @code{ra-reshape}, @code{ra-ravel}, and @code{ra-tile} operate on prefix axes. To operate on other axes, use @ref{x-ra-transpose, @code{ra-transpose}}.

@c ------------------------------------------------
@node Other operations on arrays
@section Other operations on arrays
@c ------------------------------------------------

@c @cindex @code{none}
@c @anchor{x-none}
@c @deffn @w{Special objects} {none}
@c For example...

@c @example
@c @verbatim
@c For example
@c @end verbatim
@c @end example

@c @end deffn

@c ------------------------------------------------
@node Compatibility with old Guile arrays
@section Compatibility with old Guile arrays
@c ------------------------------------------------

@c ------------------------------------------------
@node Advanced usage
@chapter Advanced usage
@c ------------------------------------------------

@menu
* Rank polymorphism and rank extension::
* Verbs::
* Reductions::
* Foreign interface::
@end menu

@c ------------------------------------------------
@node Rank polymorphism and rank extension
@section Rank polymorphism and rank extension
@c ------------------------------------------------

@c ------------------------------------------------
@node Verbs
@section Verbs
@c ------------------------------------------------

@c ------------------------------------------------
@node Reductions
@section Reductions
@c ------------------------------------------------

@c ------------------------------------------------
@node Foreign interface
@section Foreign interface
@c ------------------------------------------------

@c ------------------------------------------------
@node Hazards
@chapter Hazards
@c ------------------------------------------------

@c ------------------------------------------------
@node Reference
@chapter Reference
@c ------------------------------------------------

@cindex @code{make-ra-new}
@anchor{x-make-ra-new}
@deffn @w{function} make-ra-new type value dims
Create a new array of the given @var{type} and fill it with @var{value}.
@example
@verbatim
(make-ra-new 'u8 0 (c-dims 3 2))
@end verbatim
@result{} #%2u8:3:2((0 0) (0 0) (0 0))
@end example
@end deffn

@cindex @code{make-ra-root}
@anchor{x-make-ra-root}
@deffn @w{function} make-ra-root dims [zero]

@example
@verbatim
(make-ra-root (vector 1 2 3) (vector (make-dim 3)))
@end verbatim
@result{} #%1d:3(1 2 3)
@end example

@example
@verbatim
(make-ra-root (vector 1 2 3) (vector (make-dim 2)) 1)
@end verbatim
@result{} #%1d:3(2 3)
@end example
@end deffn

@cindex @code{make-ra}
@anchor{x-make-ra}
@deffn @w{function} make-ra val bounds ...
@end deffn

@cindex @code{make-typed-ra}
@anchor{x-make-typed-ra}
@deffn @w{function} make-typed-ra type val bounds ...
@end deffn

@cindex @code{c-dims}
@anchor{x-c-dims}
@deffn @w{function} c-dims bounds ...

Create dims for C-order array (packed elements, last dimension changing fastest).

Each of the bounds may be an integer (a length) or a pair of integers (lower and upper bounds).
@example
@verbatim
(c-dims 2 3)
@end verbatim
@result{} #(#<<dim> len: 2 lo: 0 step: 3> #<<dim> len: 3 lo: 0 step: 1>)
@end example
@end deffn

@cindex @code{ra-iota}
@anchor{x-ra-iota}
@deffn @w{function} ra-iota [len [lo [step]]]

Create rank-1 index array. The root is of type @code{<aseq>}.

@example
@verbatim
(ra-iota 4 3 -1)
@end verbatim
@result{} #%1d:4(3 2 1 0)
@end example
@end deffn

@cindex @code{ra-i}
@anchor{x-ra-i}
@deffn @w{function} ra-i len ...

Create multidimensional index array with the given lengths. The root is of type @code{<aseq>}.

@example
@verbatim
(ra-i 2 3 4)
@end verbatim
@result{} #%3d:2:3:4(((0 1 2 3) (4 5 6 7) (8 9 10 11)) ((12 13 14 15) (16 17 18 19) (20 21 22 23)))
@end example
@end deffn

@cindex @code{ra-ravel}
@anchor{x-ra-ravel}
@deffn @w{function} ra-ravel a [n]
Ravel the first @var{n} axes of array @var{a} to C order, the whole array by default.
@example
@verbatim
(ra-ravel (ra-i 2 3))
@end verbatim
@result{} #%1d:6(0 1 2 3 4 5)
@end example
@end deffn

@cindex @code{ra-reshape}
@anchor{x-ra-reshape}
@deffn @w{function} ra-reshape a bounds ...
Reshape the first axis of array @var{a} to @var{bounds}.

Each of the bounds may be an integer (a length) or a pair of integers (lower and upper bounds).
@example
@verbatim
(ra-reshape (ra-i 4 3) 2 2)
@end verbatim
@result{} #%1d:2:2:3(((0 1 2) (3 4 5)) ((6 7 8) (9 10 11)))
@end example
@end deffn

@cindex @code{ra-tile}
@anchor{x-ra-tile}
@deffn @w{function} ra-tile a bounds ...
Repeat array @var{a} by prepending axes with the given @var{bounds}.

Each of the bounds may be an integer (a length) or a pair of integers (lower and upper bounds).
@example
@verbatim
(ra-tile (ra-i 3) 2)
@end verbatim
@result{} #%1d:2:3((0 1 2) (0 1 2))
@end example
@end deffn

@cindex @code{ra-transpose}
@anchor{x-ra-transpose}
@deffn @w{function} ra-transpose a axes ...
Transpose each axis of @var{a} to matching destination @var{axes}.

The transposed array has the same root as @var{a}.
@example
@verbatim
(ra-transpose (ra-i 2 3) 1 0)
@end verbatim
@result{} #%1d:3:2((0 3) (1 4) (2 5))
@end example
@end deffn

@cindex @code{ra-reverse}
@anchor{x-ra-reverse}
@deffn @w{function} ra-reverse a axes ...
Reverse the given @var{axes} of @var{a}.

The transposed array has the same root as @var{a}.
@example
@verbatim
(ra-reverse (ra-i 2 3) 0 1)
@end verbatim
@result{} #%1d:2:3((5 4 3) (2 1 0))
@end example
@end deffn

@cindex @code{ra-index-map!}
@anchor{x-ra-index-map!}
@deffn @w{function} ra-index-map! a op
Iterate over array @var{a}, and for each element store the result of @code{(op i₀ ...)}, where @code{i₀ ...} are the indices of that element.
@end deffn

@cindex @code{ra-slice-for-each}
@anchor{x-ra-slice-for-each}
@deffn @w{function} ra-slice-for-each k op a ...
Iterate over the @var{k}-frames of arrays @var{a} ..., applying @var{op} to the respective slices.
@end deffn

@cindex @code{ra-map!}
@anchor{x-ra-map!}
@deffn @w{function} ra-map! dst op a ...
Iterate over arrays @var{dst} and @var{a}, applying @var{op} to the respective elements in @var{a}, and storing the result in @var{dst}. All the arrays involved must have the same bounds.

This is equivalent to
@verbatim
(apply ra-slice-for-each
       (rank dst)
       (lambda (dst . a)
         (ra-set! dst (apply op (map ra-ref a))))
       dst a)
@end verbatim
@end deffn

@c ------------------------------------------------
@node @mybibnode{}
@chapter Sources
@c ------------------------------------------------

@multitable @columnfractions .1 .9

@item @mybibitem{Abr70} @tab Philip S. Abrams. An APL machine. Technical report SLAC-114 UC-32 (MISC), Stanford Linear Accelerator Center, Stanford University, Stanford, CA, USA, February 1970.
@item @mybibitem{Ber87} @tab Robert Bernecky. An introduction to function rank. ACM SIGAPL APL Quote Quad, 18(2):39–43, December 1987.
@item @mybibitem{bli17} @tab The Blitz++ meta-template library. @url{http://blitz.sourceforge.net}, November 2017.
@item @mybibitem{Cha86} @tab Gregory J. Chaitin. Physics in APL2, June 1986.
@item @mybibitem{FI68}  @tab Adin D. Falkoff and Kenneth Eugene Iverson. APL\360 User’s manual. IBM Thomas J. Watson Research Center, August 1968.
@item @mybibitem{FI73}  @tab Adin D. Falkoff and Kenneth Eugene Iverson. The design of APL. IBM Journal of Research and Development, 17(4):5–14, July 1973.
@item @mybibitem{FI78}  @tab Adin D. Falkoff and Kenneth Eugene Iverson. The evolution of APL. ACM SIGAPL APL, 9(1):30– 44, 1978.
@item @mybibitem{J S}   @tab J Primer. J Software, @url{https://www.jsoftware.com/help/primer/contents.htm}, November 2017.
@item @mybibitem{Mat}   @tab MathWorks. MATLAB documentation, @url{https://www.mathworks.com/help/matlab/}, November 2017.
@item @mybibitem{num17} @tab NumPy. @url{http://www.numpy.org}, November 2017.
@item @mybibitem{Ric08} @tab Henry Rich. J for C programmers, February 2008.
@item @mybibitem{SSM14} @tab Justin Slepak, Olin Shivers, and Panagiotis Manolios. An array-oriented language with static rank polymorphism. In Z. Shao, editor, ESOP 2014, LNCS 8410, pages 27–46, 2014.
@item @mybibitem{Vel01} @tab Todd Veldhuizen. Blitz++ user’s guide, February 2001.
@item @mybibitem{Wad90} @tab Philip Wadler. Deforestation: transforming programs to eliminate trees. Theoretical Computer Science, 73(2): 231--248, June 1990. @url{https://doi.org/10.1016/0304-3975%2890%2990147-A}

@end multitable

@c ------------------------------------------------
@node Indices
@unnumbered Indices
@c ------------------------------------------------

@c @node Concept Index
@c @unnumbered Concept Index
@printindex cp
@c @node Function Index
@c @unnumbered Function Index
@c @printindex fn

@c \nocite{JLangReference,FalkoffIverson1968,Abrams1970,FalkoffIverson1973,FalkoffIverson1978,APLexamples1,ArraysCowan,KonaTheLanguage,blitz++2001}

@bye
