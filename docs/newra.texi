@c -*-texinfo-*-
@c %**start of header
@setfilename newra.info
@documentencoding UTF-8
@settitle newra —An array library for Guile 3
@c %**end of header
@c last [ma112]

@set VERSION 1
@set UPDATED 2019 November 11

@copying
@code{newra} (version @value{VERSION}, updated @value{UPDATED})

(c) lloda 2017--2019

@smalldisplay
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
@end smalldisplay
@end copying

@dircategory Guile libraries
@direntry
* newra: (newra.info).  Array library for Guile meant to replace the built-in array facility.
@end direntry

@include my-bib-macros.texi
@mybibuselist{Sources}

@titlepage
@title newra
@subtitle version @value{VERSION}, updated @value{UPDATED}
@author lloda
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@ifnottex
@node Top
@top @code{newra}

@insertcopying

@code{newra} is a Scheme-only replacement for the array facility in Guile 2.2, which is implemented in C.

@menu
* Overview::          Why Guile arrays need replacing
* Basics::            Using arrays as containers
* Advanced usage::    Guile as an array language.
* Hazards::           User beware.
* Reference::         Systematic list of types and functions.
* @mybibnode{}::      It's been done before.
* Indices::           Or try the search function.
@end menu

@end ifnottex

@iftex
@shortcontents
@end iftex

@c ------------------------------------------------
@node Overview
@chapter Overview
@c ------------------------------------------------

An array is an aggregate of the following pieces:

@itemize
@item A @dfn{root vector}.
This can be a Scheme vector, as well as one of several other vector-like types.
@item A @dfn{zero}.
An arbitary integer.
@item A @dfn{dim vector}.
Each dim consists of a length (@dfn{len}), a lower bound (@dfn{lo}), and a @dfn{step}. The length of the dim vector is the @dfn{rank} of the array.
@end itemize

Together, the dim vector and the zero define an affine function of array indices @code{i₀, i₁, ..} that produces an index into the root vector (or root for short). Thus, the array is simply a multidimensional view of the root.

For example, the following pieces

@itemize
@item root: v = @code{#(1 2 3 4 5 6 7)}
@item zero: 1
@item dims: @code{#(#<<dim> len: 2 lo: 0 step: 2> #<<dim> len: 2 lo: 0 step: 1>)}
@end itemize

define an array A(i₀, i₁) = v(1 + 2·i₀ + 1·i₁), 0≤i₀<2, 0≤i₁<2, that is A = [[2 3] [4 5]].

In @code{newra} code,

@example @c [ma106]
@verbatim
(make-ra-raw (vector 1 2 3 4 5 6 7) 1 (vector (make-dim 2 0 2) (make-dim 2 0 1)))
@end verbatim
@result{} @code{#%2:2:2((2 3) (4 5))}
@end example

The default print style means @code{#%RANK:LEN₀:LEN₁(...)}.

It's unusual to need to specify the dims directly. More commonly, one creates an array of whatever size

@verbatim
> (define a (make-ra #f 3 4))
> a
@end verbatim
@result{} @code{#%2:3:4((#f #f #f #f) (#f #f #f #f) (#f #f #f #f))}

which automatically creates a root of the required size, so that all the array elements are distinct. Then one operates on the array without making reference to the underlying root,

@verbatim
> (ra-set! a 99 2 2)
@end verbatim
@result{} @code{#%2:3:4((#f #f #f #f) (#f #f 99 #f) (#f #f #f #f))}

Still, since the array is just a view of the root, any changes on the array are reflected there as well

@verbatim
> (ra-root a)
@end verbatim
@result{} @code{#(#f #f #f #f #f #f #f #f #f #f 99 #f)}

and the other way around,

@verbatim
> (define b (make-ra-raw (vector 'x) 0 (vector (make-dim 3 0 0) (make-dim 2 0 0))))
> b
@end verbatim
@result{} @code{#%2:3:2((x x) (x x) (x x))}

@verbatim
> (vector-set! (ra-root b) 0 'Z)
> b
@end verbatim
@result{} @code{#%2:3:2((Z Z) (Z Z) (Z Z))}

@emph{expressions} @dfn{matrices}

@verbatim
A = B+C;
@end verbatim

@cindex Guile
Text to be written

@menu
* Built-in Guile arrays::
@end menu

@c ------------------------------------------------
@node Built-in Guile arrays
@section Built-in Guile arrays
@c ------------------------------------------------

Dense multidimensional arrays work similarly in every language that offers them, and built-in Guile arrays are no different —they also have a root (@code{shared-array-root}), a zero (computable from @code{shared-array-offset}), and a dim vector (@code{array-shape}, @code{shared-array-increments}). Functionally, they are entirely equivalent to the objects offered by @code{newra}. Why replace them, then?

Built-in Guile arrays are implemented in C, in libguile. As a Guile type they have their own low-level type tag, and all the basic array operations are C stubs, even the most basic functions such as @code{array-ref} or @code{array-rank}. Obtaining any of the components of the array requires calling into C. There are several problems with this.

First, the built-in library offers a single function to manipulate array dims, @code{make-shared-array}. Although this is a sufficient interface, it is excessively generic, and also very cumbersome and inefficient. The array dims cannot be manipulated directly from Scheme, so any alternative interface written in Scheme is forced to go through @code{make-shared-array}.

Second, the C stubs create a barrier to optimization by the Scheme compiler. An operation such as @code{(array-map! c + a b)} has to be implemented in C (for the reasons given above) and then it has to call back to Scheme to perform the @code{+} on each iteration. Since the Scheme compiler doesn't have any special support for @code{array-map!}, it doesn't know what the types of the arguments are, etc. so those checks and dispatches have to be repeated over and over. @footnote{Guile used to offer dedicated operations to sum arrays, etc. but obviously that isn't any kind of solution.}

Third, the larger functions of the array interface, such as @code{array-map!}, etc. are not interruptible. This is especially inconvenient when operating on large arrays.

All these problems are solved if the built-in type is replaced with a new type defined in Scheme.

@anchor{x-star}
FIXME (see @ref{x-star,@code{star}})

@c ------------------------------------------------
@node Basics
@chapter Basics
@c ------------------------------------------------

@menu
* Creating arrays::
* Special arrays::
* Iteration::
* Slicing::
* Reshaping and resizing::
* Other operations on arrays::
* Compatibility with old Guile arrays::
@end menu

@c ------------------------------------------------
@node Creating arrays
@section Creating arrays
@c ------------------------------------------------

@c ------------------------------------------------
@node Special arrays
@section Special arrays
@c ------------------------------------------------

Any type that is usable as root of an old built-in Guile array is also usable as root of a @code{newra} array. These include

@itemize
@item vectors (e.g. @code{(vector 3)})
@item SRFI-4 typed vectors (e.g. @code{(c64vector 1 2+0i)})
@item strings (e.g. @code{"hello"})
@item bitvectors (e.g. @code{(bitvector #f #t #f #t)})
@end itemize

@code{newra} supports an additional root vector type, @code{<aseq>}, representing an infinite arithmetic sequence.

@cindex @code{none}
@anchor{x-none}
@deffn @w{function} make-aseq [org [inc]]

Create an arithmetic sequence [@code{org, org+inc, org+2·inc, ...}]. The default values of @code{org} and @code{inc} are respectively 0 and 1. For example:

@example
@verbatim
(make-ra-raw (make-aseq 0 3) 0 (vector (make-dim 10)))
@end verbatim
@result{} #%1d:10(0 3 6 9 12 15 18 21 24 27)
@end example

(The example above can also be written @code{(@ref{x-ra-iota, ra-iota} 10 0 3)}).
@end deffn

@code{aseq} roots are immutable. The type tag of @code{aseq} roots is @code{d}. Arrays with integer-valued @code{aseq} roots have special uses; see @ref{Slicing}.

@c ------------------------------------------------
@node Iteration
@section Iteration
@c ------------------------------------------------

@c ------------------------------------------------
@node Slicing
@section Slicing
@c ------------------------------------------------

@c ------------------------------------------------
@node Reshaping and resizing
@section Reshaping and resizing
@c ------------------------------------------------

@c ------------------------------------------------
@node Other operations on arrays
@section Other operations on arrays
@c ------------------------------------------------

@c @cindex @code{none}
@c @anchor{x-none}
@c @deffn @w{Special objects} {none}
@c For example...

@c @example
@c @verbatim
@c For example
@c @end verbatim
@c @end example

@c @end deffn

@c ------------------------------------------------
@node Compatibility with old Guile arrays
@section Compatibility with old Guile arrays
@c ------------------------------------------------

@c ------------------------------------------------
@node Advanced usage
@chapter Advanced usage
@c ------------------------------------------------

@c ------------------------------------------------
@node Hazards
@chapter Hazards
@c ------------------------------------------------

@c ------------------------------------------------
@node Reference
@chapter Reference
@c ------------------------------------------------

@cindex @code{ra-iota}
@anchor{x-ra-iota}
@deffn @w{function} ra-iota [len [lo [step]]]

Create rank-1 index array. The root is of type @code{<aseq>}.

@example
@verbatim
(ra-iota 4 3 -1)
@end verbatim
@result{} #%1d:4(3 2 1 0)
@end example
@end deffn

@cindex @code{ra-i}
@anchor{x-ra-i}
@deffn @w{function} ra-i len ...

Create multidimensional index array with the given lengths. The root is of type @code{<aseq>}.

@example
@verbatim
(ra-i 2 3 4)
@end verbatim
@result{} #%3d:2:3:4(((0 1 2 3) (4 5 6 7) (8 9 10 11)) ((12 13 14 15) (16 17 18 19) (20 21 22 23)))
@end example
@end deffn

@c ------------------------------------------------
@node @mybibnode{}
@chapter Sources
@c ------------------------------------------------

@multitable @columnfractions .1 .9

@item @mybibitem{Abr70} @tab Philip S. Abrams. An APL machine. Technical report SLAC-114 UC-32 (MISC), Stanford Linear Accelerator Center, Stanford University, Stanford, CA, USA, February 1970.
@item @mybibitem{Ber87} @tab Robert Bernecky. An introduction to function rank. ACM SIGAPL APL Quote Quad, 18(2):39–43, December 1987.
@item @mybibitem{bli17} @tab The Blitz++ meta-template library. @url{http://blitz.sourceforge.net}, November 2017.
@item @mybibitem{Cha86} @tab Gregory J. Chaitin. Physics in APL2, June 1986.
@item @mybibitem{FI68}  @tab Adin D. Falkoff and Kenneth Eugene Iverson. APL\360 User’s manual. IBM Thomas J. Watson Research Center, August 1968.
@item @mybibitem{FI73}  @tab Adin D. Falkoff and Kenneth Eugene Iverson. The design of APL. IBM Journal of Research and Development, 17(4):5–14, July 1973.
@item @mybibitem{FI78}  @tab Adin D. Falkoff and Kenneth Eugene Iverson. The evolution of APL. ACM SIGAPL APL, 9(1):30– 44, 1978.
@item @mybibitem{J S}   @tab J Primer. J Software, @url{https://www.jsoftware.com/help/primer/contents.htm}, November 2017.
@item @mybibitem{Mat}   @tab MathWorks. MATLAB documentation, @url{https://www.mathworks.com/help/matlab/}, November 2017.
@item @mybibitem{num17} @tab NumPy. @url{http://www.numpy.org}, November 2017.
@item @mybibitem{Ric08} @tab Henry Rich. J for C programmers, February 2008.
@item @mybibitem{SSM14} @tab Justin Slepak, Olin Shivers, and Panagiotis Manolios. An array-oriented language with static rank polymorphism. In Z. Shao, editor, ESOP 2014, LNCS 8410, pages 27–46, 2014.
@item @mybibitem{Vel01} @tab Todd Veldhuizen. Blitz++ user’s guide, February 2001.
@item @mybibitem{Wad90} @tab Philip Wadler. Deforestation: transforming programs to eliminate trees. Theoretical Computer Science, 73(2): 231--248, June 1990. @url{https://doi.org/10.1016/0304-3975%2890%2990147-A}

@end multitable

@c ------------------------------------------------
@node Indices
@unnumbered Indices
@c ------------------------------------------------

@c @node Concept Index
@c @unnumbered Concept Index
@printindex cp
@c @node Function Index
@c @unnumbered Function Index
@c @printindex fn

@c \nocite{JLangReference,FalkoffIverson1968,Abrams1970,FalkoffIverson1973,FalkoffIverson1978,APLexamples1,ArraysCowan,KonaTheLanguage,blitz++2001}

@bye
