@c -*-texinfo-*-
@c %**start of header
@setfilename newra.info
@documentencoding UTF-8
@settitle newra —An array library for Guile 3
@c %**end of header
@c last [ma112]

@set VERSION 1
@set UPDATED 2019 November 14

@copying
@code{newra} (version @value{VERSION}, updated @value{UPDATED})

(c) lloda 2017--2019

@smalldisplay
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
@end smalldisplay
@end copying

@dircategory Guile libraries
@direntry
* newra: (newra.info).  Array library for Guile meant to replace the built-in array facility.
@end direntry

@include my-bib-macros.texi
@mybibuselist{Sources}

@titlepage
@title newra
@subtitle version @value{VERSION}, updated @value{UPDATED}
@author lloda
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@ifnottex
@node Top
@top @code{newra}

@insertcopying

@code{newra} is a Scheme-only replacement for the built-in C-based array facility in Guile 2.2.

This document uses ‘array’ to refer both to the old built-in array type and to the new type introduced in @code{newra}. The distinction is made as necessary.

@menu
* Overview::          Why Guile arrays need replacing.
* Basics::            Using arrays as containers.
* Advanced usage::    Guile as an array language.
* Hazards::           User beware.
* Reference::         Systematic list of types and functions.
* @mybibnode{}::      It's been done before.
* Indices::           Or try the search function.
@end menu

@end ifnottex

@iftex
@shortcontents
@end iftex

@c ------------------------------------------------
@node Overview
@chapter Overview
@c ------------------------------------------------

A multidimensional array is a container (or rather a container view) whose elements can be looked up using a multi-index (i₀, i₁, ...). Each of the indices i₀, i₁, ... has a constant range [l₀, h₀], [l₁, h₁], ... independent of the values of the other indices, so the array is ‘rectangular’. The number of indices in the multi-index is the @dfn{rank} of the array, and the list ((l₀ h₀) (l₁ h₁) ... (lᵣ₋₁ hᵣ₋₁)) is the @dfn{shape} of the array. We speak of a rank-@math{r} array or of an @math{r}-array.

Sometimes we deal with multidimensional @emph{expressions} where the elements aren't stored anywhere, but are computed on demand when the expression is looked up. In this general sense, an ‘array’ is just a function of integers with a rectangular domain. Such an array would be immutable.

Arrays (in the form of @dfn{matrices}, @dfn{vectors}, or @dfn{tensors}) are very common objects in math and programming, and it is very useful to be able to manipulate arrays as individual entities rather than as aggregates — that is one of the main purposes of @code{newra}.

@menu
* Rank polymorphism and rank extension::
* The pieces of an array::
* Built-in Guile arrays::
@end menu

@c ------------------------------------------------
@node Rank polymorphism and rank extension
@section Rank polymorphism and rank extension
@c ------------------------------------------------

@cindex rank polymorphism
@dfn{Rank polymorphism} is the ability to treat an array of rank @math{r} as an array of lower rank where the elements are themselves arrays.

@cindex cell
@cindex frame
Think of a matrix A, a 2-array with sizes (n₀, n₁) where the elements A(i₀, i₁) are numbers. If we consider the subarrays (rows) A(0, ...), A(1, ...), ..., A(n₀-1, ...) as individual elements, then we have a new view of A as a 1-array of size n₀ with those rows as elements. We say that the rows A(i₀)≡A(i₀, ...) are the 1-@dfn{cells} of A, and the numbers A(i₀, i₁) are 0-cells of A. For an array of arbitrary rank @math{r} the (@math{r}-1)-cells of A are called its @dfn{items}. The prefix of the shape (n₀, n₁, ... nₙ₋₁₋ₖ) that is not taken up by the k-cell is called the k-@dfn{frame}.

An obvious way to store an array in linearly addressed memory is to place its items one after another. So we would store a 3-array as

@quotation
A: [A(0), A(1), ...]
@end quotation

and the items of A(i₀), etc. are in turn stored in the same way, so

@quotation
A: [A(0): [A(0, 0), A(0, 1) ...], ...]
@end quotation

and the same for the items of A(i₀, i₁), etc.

@quotation
A: [[A(0, 0): [A(0, 0, 0), A(0, 0, 1) ...], A(0, 1): [A(0, 1, 0), A(0, 1, 1) ...]], ...]
@end quotation

@cindex order, row-major
This way to lay out an array in memory is called @dfn{row-major order} or @dfn{C-order}, since it's the default order for built-in arrays in C. A row-major array A with sizes (n₀, n₁, ... nᵣ₋₁) can be looked up like this:

@anchor{x-strides}
@quotation
A(i₀, i₁, ...) = (storage-of-A) [(((i₀n₁ + i₁)n₂ + i₂)n₃ + ...)+iᵣ₋₁] = (storage-of-A) [o + s₀i₀ + s₁i₁ +  ...]
@end quotation

where the numbers (s₀, s₁, ...) are called the @dfn{strides}@footnote{Cf. @url{https://en.wikipedia.org/wiki/Dope_vector, @dfn{dope vector}}}. Note that the ‘linear’ or ‘raveled’ address [o + s₀i₀ + s₁i₁ +  ...] is an affine function of (i₀, i₁, ...). If we represent an array as a tuple

@quotation
A ≡ ((storage-of-A), o, (s₀, s₁, ...))
@end quotation

then any affine transformation of the indices can be achieved simply by modifying the numbers (o, (s₀, s₁, ...)), with no need to touch the storage. This includes very common operations such as: @ref{x-ra-transpose,transposing} axes, @ref{x-ra-reverse,reversing} the order along an axis, most cases of @ref{Slicing,slicing}, and sometimes even reshaping or tiling the array.

A basic example is obtaining the i₀-th item of A:

@quotation
A(i₀) ≡ ((storage-of-A), o+s₀i₀, (s₁, ...))
@end quotation

Note that we can iterate over these items by simply bumping the pointer o+s₀i₀. This means that iterating over (k>0)-cells doesn't have to cost any more than iterating over 0-cells (@ref{x-ra-slice-for-each,@code{ra-slice-for-each}}).

@c ------------------------------------------------
@node The pieces of an array
@section The pieces of an array
@c ------------------------------------------------

An @code{newra} array is in fact an aggregate of the following pieces:

@cindex rank
@cindex dim vector
@cindex root vector
@itemize
@item A @dfn{root vector}.
This can be a Scheme vector, as well as one of several other vector-like types.
@item A @dfn{zero}.
An arbitary integer.
@item A @dfn{dim vector}.
Each dim consists of a length (@dfn{len}), a lower bound (@dfn{lo}), and a @dfn{step}. The length of the dim vector is the @dfn{rank} of the array.
@end itemize

Together, the dim vector and the zero define an affine function of array indices @code{i₀, i₁, ..} that produces an index into the root vector (or root for short). Thus, the array is simply a multidimensional view of the root.

For example, the following pieces

@itemize
@item root: v = @code{#(1 2 3 4 5 6 7)}
@item zero: 1
@item dims: @code{#(#<<dim> len: 2 lo: 0 step: 2> #<<dim> len: 2 lo: 0 step: 1>)}
@end itemize

define an array A(i₀, i₁) = v(1 + 2·i₀ + 1·i₁), 0≤i₀<2, 0≤i₁<2, that is A = [[2 3] [4 5]].

In @code{newra} code,

@example @c [ma106]
@verbatim
(make-ra-root (vector 1 2 3 4 5 6 7) 1 (vector (make-dim 2 0 2) (make-dim 2 0 1)))
@end verbatim
@result{} @code{#%2:2:2((2 3) (4 5))}
@end example

The default print style means @code{#%RANK:LEN₀:LEN₁(...)}.

It's unusual to need to specify the dims directly. More commonly, one creates an array of whatever size

@verbatim
> (define a (make-ra #f 3 4))
> a
@end verbatim
@result{} @code{#%2:3:4((#f #f #f #f) (#f #f #f #f) (#f #f #f #f))}

which automatically creates a root of the required size, so that all the array elements are distinct. Then one operates on the array without making reference to the underlying root,

@verbatim
> (ra-set! a 99 2 2)
@end verbatim
@result{} @code{#%2:3:4((#f #f #f #f) (#f #f 99 #f) (#f #f #f #f))}

Still, since the array is just a view of the root, any changes on the array are reflected there as well

@verbatim
> (ra-root a)
@end verbatim
@result{} @code{#(#f #f #f #f #f #f #f #f #f #f 99 #f)}

and the other way around,

@verbatim
> (define b (make-ra-root (vector 'x) 0 (vector (make-dim 3 0 0) (make-dim 2 0 0))))
> b
@end verbatim
@result{} @code{#%2:3:2((x x) (x x) (x x))}

@verbatim
> (vector-set! (ra-root b) 0 'Z)
> b
@end verbatim
@result{} @code{#%2:3:2((Z Z) (Z Z) (Z Z))}

@emph{expressions} @dfn{matrices}

@verbatim
A = B+C;
@end verbatim

@cindex Guile
Text to be written

@c ------------------------------------------------
@node Built-in Guile arrays
@section Built-in Guile arrays
@c ------------------------------------------------

Dense multidimensional arrays work similarly in every language that offers them, and built-in Guile arrays are no different —they also have a root (@code{shared-array-root}), a zero (computable from @code{shared-array-offset} and @code{array-shape}), and a dim vector (@code{array-shape}, @code{shared-array-increments}). Functionally, they are entirely equivalent to the objects offered by @code{newra}. Why replace them, then?

@cindex libguile
Built-in Guile arrays are implemented in C, as part of libguile. As a Guile type they have their own low-level type tag, and all the basic array operations are C stubs, even the most basic functions such as @code{array-ref} or @code{array-rank}. Obtaining any of the components of the array requires calling into C. There are several problems with this.

First, the built-in library offers a single function to manipulate array dims, @code{make-shared-array}. Although this is a sufficient interface, it is excessively generic, and also very cumbersome and inefficient. The array dims cannot be manipulated directly from Scheme, so any alternative interface written in Scheme is forced to go through @code{make-shared-array}.

Second, the C stubs create a barrier to optimization by the Scheme compiler. The main loop of an operation such as @code{(array-map! c + a b)} has to be implemented in C (for the reasons given above) and then it has to call back to Scheme on each iteration in order to apply @code{+}. Since the Scheme compiler doesn't have any special support for @code{array-map!}, it doesn't know what the types of the arguments are, etc. and those checks and dispatches are repeated over and over. @footnote{Guile used to offer dedicated operations to sum arrays, etc. but obviously that isn't any kind of solution.}

Third, the larger functions of the array interface, such as @code{array-map!}, etc. are not interruptible. This is especially inconvenient when operating on large arrays.

These problems are solved if the built-in type is replaced with a new type defined in Scheme.

@c ------------------------------------------------
@node Basics
@chapter Basics
@c ------------------------------------------------

@menu
* Creating arrays::
* Special arrays::
* Iteration::
* Slicing::
* Reshaping and resizing::
* Other operations on arrays::
* Compatibility with old Guile arrays::
@end menu

@c ------------------------------------------------
@node Creating arrays
@section Creating arrays
@c ------------------------------------------------

An array can be created anew (@ref{x-make-ra-new, @code{make-ra-new}}), or over an existing root (@ref{x-make-ra-root, @code{make-ra-root}}). @ref{x-c-dims, @code{c-dims}} can be used to compute the dim vector.

@example
@verbatim
(make-ra-new #t 'x (vector (make-dim 3 0 2) (make-dim 2 0 1))) ; more simply
(make-ra-new #t 'x (c-dims 3 2))
@end verbatim
@result{} #%2:3:2((x x) (x x) (x x))
@end example

@example
@verbatim
(make-ra-new 'f32 0.0 (c-dims 3 2))
@end verbatim
@result{} #%2f32:3:2((0.0 0.0) (0.0 0.0) (0.0 0.0))
@end example

An existing root implies the type, so it doesn't need to be given.

@example
@verbatim
(make-ra-root (vector 1 2 3 4 5 6) (c-dims 3 2))
@end verbatim
@result{} #%2:3:2((1 2) (3 4) (5 6))
@end example

@ref{x-make-ra, @code{make-ra}} or @ref{x-make-typed-ra, @code{make-typed-ra}} use @code{c-dims} by default.

@example
@verbatim
(make-ra 99 2 3)
@end verbatim
@result{} #%2:3:2((9 9) (9 9) (9 9))
@end example

@example
@verbatim
(make-typed-ra 'f64 99 2 3)
@end verbatim
@result{} #%2f64:3:2((9.0 9.0) (9.0 9.0) (9.0 9.0))
@end example

@c ------------------------------------------------
@node Special arrays
@section Special arrays
@c ------------------------------------------------

Any type that is usable as the root of an old built-in Guile array is also usable as root of a @code{newra} array. These include

@itemize
@item vectors (e.g. @code{(vector 3)})
@item SRFI-4 typed vectors (e.g. @code{(c64vector 1 2+0i)})
@item strings (e.g. @code{"hello"})
@item bitvectors (e.g. @code{(bitvector #f #t #f #t)})
@end itemize

@code{newra} supports an additional root vector type, @code{<aseq>}, representing an infinite arithmetic sequence.

@cindex @code{make-aseq}
@anchor{x-none}
@deffn @w{function} make-aseq [org [inc]]

Create an arithmetic sequence [@code{org, org+inc, org+2·inc, ...}]. The default values of @code{org} and @code{inc} are respectively 0 and 1. For example:

@example
@verbatim
(make-ra-root (make-aseq 0 3) (vector (make-dim 10)) 0)
@end verbatim
@result{} #%1d:10(0 3 6 9 12 15 18 21 24 27)
@end example

(The example above can be written @code{(@ref{x-ra-iota, ra-iota} 10 0 3)}).
@end deffn

@code{aseq} roots are immutable. The type tag of @code{aseq} roots is @code{d}. Arrays with integer-valued @code{aseq} roots have a few special uses; one of them is as arguments in @ref{Slicing, slicing}.

@cindex infinite axes
To make @code{<aseq>} even more useful, @code{newra} supports axes with infinite length.

@example
@verbatim
(ra-ref (make-ra-root (make-aseq) (vector (make-dim #f)) 0) #e1e12) ; or more simply
(ra-ref (ra-iota #f) #e1e12)
@end verbatim
@result{} 1000000000000
@end example

These are treated especially when used in iteration, in that they match axes of any finite length (@ref{x-ra-map!, @code{ra-map!}}). Effectively this lets one use @code{(@ref{x-ra-transpose, @code{ra-transpose}} (ra-iota #f) k)} as a placeholder for the index over axis @code{k}.

@example
@verbatim
(ra-map! (make-ra 0 3) + (ra-iota 3) (ra-iota #f))
@end verbatim
@result{} #1%3(0 2 4)
@end example

@cindex dead axes
@code{newra} also supports `dead axes', which are simply axes whose step is 0. These axes can have any length although effectively only one position (the lower bound, by default 0) is ever accessed. Some functions work purely by creating dead axes.

@example
@verbatim
(define A (make-ra-root #(1 2 3) (c-dims 3)))
(ra-tile A 2 2)
@end verbatim
@result{} #%3d:2:2:3(((0 1 2) (0 1 2)) ((0 1 2) (0 1 2)))
@verbatim
(ra-dims (ra-tile A 2 2))
@end verbatim
@result{} #(#<<dim> len: 2 lo: 0 step: 0> #<<dim> len: 2 lo: 0 step: 0> #<<dim> len: 3 lo: 0 step: 1>)
@end example

@cindex singleton axis
When an axis has 0 step and infinite length, it operates essentially as ‘singleton axes’ operate in other array languages. The main diference is that the ability to match any finite length is explicit; an axis with length 1 will still fail to match an axis with length 2.

@c ------------------------------------------------
@node Iteration
@section Iteration
@c ------------------------------------------------

The basic array iteration operations in @code{newra} all operate by effect. This gives you control of how the result is allocated. If one of the arguments is designated as destination, as is the case with @ref{x-ra-map!, @code{ra-map!}}, then that is the result of the whole iteration. For example:

@example
@verbatim
(ra-map! (make-ra #f 3) - (ra-iota 3 1))
@end verbatim
@result{} #%1:3(-1 -2 -3)
@end example

It is common to need the indices of the elements during array iteration. @code{newra} iteration operations do not keep track of those indices@footnote{Except for @ref{x-ra-index-map!, @code{ra-index-map!}}, which is provided out of compatibility with the older array system.} because it isn't free to do so. You need to pass the indices you need as arguments, but it's easy to do so by using an infinite index vector together with @ref{x-ra-transpose, @code{ra-transpose}}.

@example
@verbatim
(define i0 (ra-iota #f))
(define i1 (ra-transpose (ra-iota #f) 1))
(ra-map! (make-ra #f 2 2) list (list->ra 2 '((A B) (C D))) i0 i1)
@end verbatim
@result{} #%2:2:2(((A 0 0) (B 0 1)) ((C 1 0) (D 1 1)))
@end example

One can iterate not only over the whole array, but also over any @code{n}-frame (the first @code{n} axes of an array), using @ref{x-ra-slice-for-each, @code{ra-slice-for-each}}. In this case the operation takes array slices as arguments, even when they are of rank 0; this allows writing to any of the arguments. When there are several arrays involved, all the frames must match.

In the following example, @code{xys} is of rank 2, @code{angle} is of rank 1, and their first axes have the same length.

@example
@verbatim
(ra-slice-for-each 1
  (lambda (xy angle)
; inside the op, xy is rank 1, angle is rank 0
    (ra-set! angle (atan (ra-ref xy 1) (ra-ref xy 0))))
  xys angles)
@end verbatim
@end example

@cindex prefix matching
The iteration procedures in @code{newra} all perform rank extension of their arguments through prefix matching (see @ref{Rank polymorphism and rank extension}). In the following example, the shapes of the arguments are (5 5), (5) and (@code{#f} 5), so the common prefixes (5), (5) and (@code{#f}) all match.

@example
@verbatim
(ra-map! (make-ra 5 5) * (ra-iota 5 1) (ra-transpose (ra-iota 5 1) 1))
@end verbatim
@result{} @code{#%2:5:5((1 2 3 4 5) (2 4 6 8 10) (3 6 9 12 15) (4 8 12 16 20) (5 10 15 20 25))}
@end example

Another example using @ref{x-ra-copy!, ra-copy!},

@example
@verbatim
(ra-copy! (list->ra 2 '((a b) (p q) (x y)))
          (list->ra 1 '(1 2 3)))
@end verbatim
@result{} @code{#%2:3:2((1 1) (2 2) (3 3))}
@end example

@c ------------------------------------------------
@node Slicing
@section Slicing
@c ------------------------------------------------

Slicing refers to the operation of taking a partial view of an array (e.g. a row or a column out of a matrix) through modification of the dim vector. This can be done with creative uses of @ref{x-ra-ravel, @code{ra-ravel}}, @ref{x-ra-reshape, @code{ra-reshape}} and @ref{x-ra-transpose, @code{ra-transpose}}, and of course by direct modification of the dim vector, but the facilities described in this section are usually a lot clearer.

@cindex prefix slice
The simplest form of slicing uses @ref{x-ra-slice, ra-slice} to produce ‘prefix slices’. It is an application of @ref{Rank polymorphism and rank extension, rank polymorphism}.

@example
@verbatim
(define a (list->ra 3 '(((a b) (x y)) ((A B) (X Y)))))
@end verbatim
@result{} @code{#%3:2:2:2(((a b) (x y)) ((A B) (X Y)))}
@verbatim
(ra-slice a 0 1 0)
@end verbatim
@result{} @code{#%0(x)}
@verbatim
(ra-slice a 0 1)
@end verbatim
@result{} @code{#%1:2(x y)}
@verbatim
(ra-slice a 0)
@end verbatim
@result{} @code{#%2:2:2((a b) (x y))}
@verbatim
(ra-slice a 0)
@end verbatim
@result{} @code{#%3:2:2:2(((a b) (x y)) ((A B) (X Y)))}
@end example

The prefix slice always shares the root of the source array, so it can be used to modify the source array.

@example
@verbatim
(ra-fill! (ra-slice a 1 0) '99)
@end verbatim
@result{} @code{#%1:2(99 99)}
@verbatim
a
@end verbatim
@result{} @code{#%3:2:2:2(((a b) (x y)) ((99 99) (X Y)))}
@end example

The variant @ref{x-ra-cell, @code{ra-cell}} is identical to @code{ra-slice} except that it returns an element (and not a rank 0 array) when the full set of indices is given.

@example
@verbatim
(ra-slice a 0 1 0)
@end verbatim
@result{} @code{x}
@end example

@code{ra-cell} is a rank-polymorphic generalization of the basic element lookup function @ref{x-ra-ref, @code{ra-ref}}, which requires the full set of indices.

@example
@verbatim
(ra-ref a 0 1 0) ; same as ra-slice
@end verbatim
@result{} @code{x}
@verbatim
(ra-ref a 0 1)
@end verbatim
@result{} @code{"<unnamed port>":...: Throw to key `bad-number-of-indices' with args `(3 2)'.}
@end example

Both @code{ra-cell} and @code{ra-slice} (and @code{ra-ref}) take scalar indices as arguments. The more powerful function @ref{x-ra-from, @code{ra-from}} is able to handle arrays of indices.

@quotation
@verbatim
(ra-from a i₀ ...) ⇒ b
@end verbatim
@end quotation

Each of the @code{i₀...} is either 1. an integer; 2. an array of integers; 3. the special value #t. Integer arguments contain indices into the respective axis of @code{a}. @code{#t} for @code{iₖ} is a shortcut for @code{(let ((d (vector-ref (ra-dims a) k))) (ra-iota (dim-len d) (dim-lo d)))}, or in human speech ‘the whole of axis @code{k}’. The result @code{b} has rank equal to the sum of all the ranks of the @code{i₀...}, and is defined as

@quotation
@verbatim
(ra-ref b j₀ ...) = (ra-ref a (ra-ref i₀ j₀ ...) ...)
@end verbatim
@end quotation

In other words, @code{ra-from} produces the outer product of the indices @code{i₀...} with operator @code{a} (if one thinks of @code{(a i₀ ...)} as @code{(ra-ref a i₀ ...)}).

If all of the @code{i₀...} are integers or arrays of type @code{d} (such as those produced by @code{ra-iota} or @code{ra-i}) then the result of @code{ra-from} shares the root of @code{a}. Otherwise @code{newra} cannot tell whether the indices are an arithmetic sequence so the result has to be copied to a new root. For example:

@example
@verbatim
(define a (list->ra 2 '((a b c) (d e f))))
@end verbatim
@result{} @code{#%2:2:3((a b c) (d e f))}
@verbatim
(ra-from a 0 #t) ; row 0, will share root
@end verbatim
@result{} @code{#%1:3(a b c)}
@verbatim
(ra-from a #t 1) ; column 1, will share root
@end verbatim
@result{} @code{#%1:2(b e)}
@verbatim
(ra-from a #t (make-ra-root #(2 0))) ; cols 2 & 0, won't share root
@end verbatim
@result{} @code{#%2:2:2((c a) (f d))}
@verbatim
(ra-from a #t (ra-iota 2 2 -2)) ; cols 2 & 0, will share root
@end verbatim
@result{} @code{#%2:2:2((c a) (f d))}
@end example

One may give fewer @code{i} than the rank of @code{a}. The missing arguments are taken as @code{#t} (see @ref{Rank polymorphism and rank extension}).

@example
@verbatim
(ra-from a 0) ; row 0, same as (ra-from a 0 #t)
@end verbatim
@result{} @code{#%1d:3(0 1 2))}
@end example

When it is known that the result of @code{ra-from} will share the root with its argument, that can be used to modify the original array. For example:

@example
@verbatim
(ra-fill! (ra-from a 1) x)
@end verbatim
@result{} @code{#%2:3((a b c) (x x x)}
@verbatim
a
@end verbatim
@result{} @code{#%2:3((a b c) (x x x))}
@end example

@ref{x-ra-amend!, @code{ra-amend!}} handles the general case:

@example
@verbatim
(define a (list->ra 2 '((a b c) (d e f))))
(ra-amend! a 'Y #t (make-ra-root #(2 0)))
@end verbatim
@result{} @code{#%2:3((Y b Y) (Y e Y))}
@verbatim
a
@end verbatim
@result{} @code{#%2:3((Y b Y) (Y e Y))}
@end example
while on the other hand
@example
@verbatim
(define a (list->ra 2 '((a b c) (d e f))))
(ra-fill! (ra-from a #t (make-ra-root #(2 0))) 'Y)
@end verbatim
@result{} @code{#%2:3((Y Y) (Y Y))}
@verbatim
a
@end verbatim
@result{} @code{#%2:3((a b c) (d e f))}
@end example

@c ------------------------------------------------
@node Reshaping and resizing
@section Reshaping and resizing
@c ------------------------------------------------

@cindex APL
@cindex ρ
To match APL dyadic ρ, @code{newra} offers a set of three different functions.

@ref{x-ra-reshape, @code{ra-reshape}} and @ref{x-ra-ravel, @code{ra-ravel}} are in a way the inverse of each other, and neither is able to increase the size of the array. For that purpose @ref{x-ra-tile, @code{ra-tile}} is provided.

@example
@verbatim
(ra-dimensions (ra-i 2 3 4))
@end verbatim
@result{} (2 3 4)
@verbatim
(ra-dimensions (ra-tile (ra-i 2 3 4) 5))
@end verbatim
@result{} (5 2 3 4)
@verbatim
(ra-dimensions (ra-ravel (ra-tile (ra-i 2 3 4) 5) 2))
@end verbatim
@result{} (10 3 4)
@verbatim
(ra-dimensions (ra-reshape (ra-ravel (ra-tile (ra-i 2 3 4) 5) 2) 2 5))
@end verbatim
@result{} (2 5 3 4)
@end example

@code{ra-reshape} and @code{ra-tile} always reuse the root of the argument. On the other hand @code{ra-ravel} may not be able to — this is one of the reasons to have three different functions instead of only one. You can check in advance whether @code{ra-ravel} will reuse the root with the function @ref{x-ra-order-c?, @code{ra-order-c?}}.

All three functions @code{ra-reshape}, @code{ra-ravel}, and @code{ra-tile} operate on prefix axes. To operate on other axes, use @ref{x-ra-transpose, @code{ra-transpose}}.

@c ------------------------------------------------
@node Other operations on arrays
@section Other operations on arrays
@c ------------------------------------------------

@c @cindex @code{none}
@c @anchor{x-none}
@c @deffn @w{Special objects} {none}
@c For example...

@c @example
@c @verbatim
@c For example
@c @end verbatim
@c @end example

@c @end deffn

@c ------------------------------------------------
@node Compatibility with old Guile arrays
@section Compatibility with old Guile arrays
@c ------------------------------------------------

@c ------------------------------------------------
@node Advanced usage
@chapter Advanced usage
@c ------------------------------------------------

@menu
* Verbs::
* Reductions::
* Foreign interface::
@end menu

@c ------------------------------------------------
@node Verbs
@section Verbs
@c ------------------------------------------------

@c ------------------------------------------------
@node Reductions
@section Reductions
@c ------------------------------------------------

@c ------------------------------------------------
@node Foreign interface
@section Foreign interface
@c ------------------------------------------------

@c ------------------------------------------------
@node Hazards
@chapter Hazards
@c ------------------------------------------------

@c ------------------------------------------------
@node Reference
@chapter Reference
@c ------------------------------------------------

@cindex @code{make-ra-new}
@anchor{x-make-ra-new}
@deffn @w{function} make-ra-new type value dims
Create an array over a new root of the given @var{type} and the necessary size (according to @var{dims}), and fill it with @var{value}.
@example
@verbatim
(make-ra-new 'u8 0 (c-dims 3 2))
@end verbatim
@result{} #%2u8:3:2((0 0) (0 0) (0 0))
@end example
@end deffn

@cindex @code{make-ra-root}
@anchor{x-make-ra-root}
@deffn @w{function} make-ra-root root [dims [zero]]
Create an array over the given @var{root}.
@example
@verbatim
(make-ra-root (vector 1 2 3))
@end verbatim
@result{} #%1d:3(1 2 3)
@end example

@example
@verbatim
(make-ra-root (vector 1 2 3) (vector (make-dim 2)))
@end verbatim
@result{} #%1d:2(1 2)
@end example

@example
@verbatim
(make-ra-root (vector 1 2 3) (vector (make-dim 2)) 1)
@end verbatim
@result{} #%1d:2(2 3)
@end example
@end deffn

@cindex @code{make-ra}
@anchor{x-make-ra}
@deffn @w{function} make-ra val bounds ...
@end deffn

@cindex @code{make-typed-ra}
@anchor{x-make-typed-ra}
@deffn @w{function} make-typed-ra type val bounds ...
@end deffn

@cindex @code{c-dims}
@anchor{x-c-dims}
@deffn @w{function} c-dims bounds ...

Create dims for C-order array (packed elements, last dimension changing fastest).

Each of the bounds may be an integer (a length) or a pair of integers (lower and upper bounds).
@example
@verbatim
(c-dims 2 3)
@end verbatim
@result{} #(#<<dim> len: 2 lo: 0 step: 3> #<<dim> len: 3 lo: 0 step: 1>)
@end example
@end deffn

@cindex @code{ra-iota}
@anchor{x-ra-iota}
@deffn @w{function} ra-iota [len [lo [step]]]

Create rank-1 index array. The root is of type @code{<aseq>}.

@example
@verbatim
(ra-iota 4 3 -1)
@end verbatim
@result{} #%1d:4(3 2 1 0)
@end example
@end deffn

@cindex @code{ra-i}
@anchor{x-ra-i}
@deffn @w{function} ra-i len ...

Create multidimensional index array with the given lengths. The root is of type @code{<aseq>}.

@example
@verbatim
(ra-i 2 3 4)
@end verbatim
@result{} #%3d:2:3:4(((0 1 2 3) (4 5 6 7) (8 9 10 11)) ((12 13 14 15) (16 17 18 19) (20 21 22 23)))
@end example
@end deffn

@cindex @code{ra-ravel}
@anchor{x-ra-ravel}
@deffn @w{function} ra-ravel a [n]
Ravel the first @var{n} axes of array @var{a} to C order, the whole array by default.
@example
@verbatim
(ra-ravel (ra-i 2 3))
@end verbatim
@result{} #%1d:6(0 1 2 3 4 5)
@end example
@end deffn

@cindex @code{ra-reshape}
@anchor{x-ra-reshape}
@deffn @w{function} ra-reshape a bounds ...
Reshape the first axis of array @var{a} to @var{bounds}.

Each of the bounds may be an integer (a length) or a pair of integers (lower and upper bounds).
@example
@verbatim
(ra-reshape (ra-i 4 3) 2 2)
@end verbatim
@result{} #%1d:2:2:3(((0 1 2) (3 4 5)) ((6 7 8) (9 10 11)))
@end example
@end deffn

@cindex @code{ra-tile}
@anchor{x-ra-tile}
@deffn @w{function} ra-tile a bounds ...
Repeat array @var{a} by prepending axes with the given @var{bounds}.

Each of the bounds may be an integer (a length) or a pair of integers (lower and upper bounds).
@example
@verbatim
(ra-tile (ra-i 3) 2)
@end verbatim
@result{} #%1d:2:3((0 1 2) (0 1 2))
@end example
@end deffn

@cindex @code{ra-transpose}
@anchor{x-ra-transpose}
@deffn @w{function} ra-transpose a axes ...
Transpose each axis of @var{a} to matching destination @var{axes}.

The transposed array has the same root as @var{a}.
@example
@verbatim
(ra-transpose (ra-i 2 3) 1 0)
@end verbatim
@result{} #%1d:3:2((0 3) (1 4) (2 5))
@end example
@end deffn

@cindex @code{ra-reverse}
@anchor{x-ra-reverse}
@deffn @w{function} ra-reverse a axes ...
Reverse the given @var{axes} of @var{a}.

The transposed array has the same root as @var{a}.
@example
@verbatim
(ra-reverse (ra-i 2 3) 0 1)
@end verbatim
@result{} #%1d:2:3((5 4 3) (2 1 0))
@end example
@end deffn

@cindex @code{ra-index-map!}
@anchor{x-ra-index-map!}
@deffn @w{function} ra-index-map! a op
Iterate over array @var{a}, and for each element store the result of @code{(op i₀ ...)}, where @code{i₀ ...} are the indices of that element.
@end deffn

@cindex @code{ra-slice-for-each}
@anchor{x-ra-slice-for-each}
@deffn @w{function} ra-slice-for-each k op a ...
Iterate over the @var{k}-frames of arrays @var{a} ..., applying @var{op} to the respective slices.
@end deffn

@cindex @code{ra-map!}
@anchor{x-ra-map!}
@deffn @w{function} ra-map! dst op a ...
Iterate over arrays @var{dst} and @var{a}, applying @var{op} to the respective elements in @var{a}, and storing the result in @var{dst}. The bounds of the arguments must match.

This is equivalent to
@verbatim
(apply ra-slice-for-each
       (rank dst)
       (lambda (dst . a)
         (ra-set! dst (apply op (map ra-ref a))))
       dst a)
@end verbatim
@end deffn

@cindex @code{ra-copy!}
@anchor{x-ra-copy!}
@deffn @w{function} ra-copy! dst src
Copy @var{src} to @var{dst}.

This is equivalent to
@verbatim
(ra-map! dst identity src)
@end verbatim
@end deffn

@cindex @code{ra-order-c?}
@anchor{x-ra-order-c?}
@deffn @w{function} ra-order-c? a [n]
Check whether the first @var{n} axes of @var{ra} are in C-order. By default, check that the whole array is in C-order, and additionally that the step on the last axis is 1 (i.e. the array is ‘packed’).

@code{(ra-order-c? a n)} implies @code{(eq? (ra-root a) (ra-root (@ref{x-ra-ravel, @code{ra-ravel}} a n)))}. Note that the stronger condition @code{(ra-order-c? a)} is not necessary for @code{(eq? (ra-root a) (ra-root (ra-ravel a)))} to hold.
@end deffn

@cindex @code{ra-ref}
@anchor{x-ra-ref}
@deffn @w{function} ra-ref a i ...
@end deffn

@cindex @code{ra-set!}
@anchor{x-ra-set!}
@deffn @w{function} ra-set! a o i ...
@end deffn

@cindex @code{ra-slice}
@anchor{x-ra-slice}
@deffn @w{function} ra-slice a i ...
@end deffn

@cindex @code{ra-cell}
@anchor{x-ra-cell}
@deffn @w{function} ra-cell a i ...
@end deffn

@cindex @code{ra-from}
@anchor{x-ra-from}
@deffn @w{function} ra-from a i ...
@end deffn

@cindex @code{ra-amend!}
@anchor{x-ra-amend!}
@deffn @w{function} ra-amend! a o i ...
@end deffn

@c ------------------------------------------------
@node @mybibnode{}
@chapter Sources
@c ------------------------------------------------

@multitable @columnfractions .1 .9

@item @mybibitem{Abr70} @tab Philip S. Abrams. An APL machine. Technical report SLAC-114 UC-32 (MISC), Stanford Linear Accelerator Center, Stanford University, Stanford, CA, USA, February 1970.
@item @mybibitem{Ber87} @tab Robert Bernecky. An introduction to function rank. ACM SIGAPL APL Quote Quad, 18(2):39–43, December 1987.
@item @mybibitem{bli17} @tab The Blitz++ meta-template library. @url{http://blitz.sourceforge.net}, November 2017.
@item @mybibitem{Cha86} @tab Gregory J. Chaitin. Physics in APL2, June 1986.
@item @mybibitem{FI68}  @tab Adin D. Falkoff and Kenneth Eugene Iverson. APL\360 User’s manual. IBM Thomas J. Watson Research Center, August 1968.
@item @mybibitem{FI73}  @tab Adin D. Falkoff and Kenneth Eugene Iverson. The design of APL. IBM Journal of Research and Development, 17(4):5–14, July 1973.
@item @mybibitem{FI78}  @tab Adin D. Falkoff and Kenneth Eugene Iverson. The evolution of APL. ACM SIGAPL APL, 9(1):30– 44, 1978.
@item @mybibitem{J S}   @tab J Primer. J Software, @url{https://www.jsoftware.com/help/primer/contents.htm}, November 2017.
@item @mybibitem{Mat}   @tab MathWorks. MATLAB documentation, @url{https://www.mathworks.com/help/matlab/}, November 2017.
@item @mybibitem{num17} @tab NumPy. @url{http://www.numpy.org}, November 2017.
@item @mybibitem{Ric08} @tab Henry Rich. J for C programmers, February 2008.
@item @mybibitem{SSM14} @tab Justin Slepak, Olin Shivers, and Panagiotis Manolios. An array-oriented language with static rank polymorphism. In Z. Shao, editor, ESOP 2014, LNCS 8410, pages 27–46, 2014.
@item @mybibitem{Vel01} @tab Todd Veldhuizen. Blitz++ user’s guide, February 2001.
@item @mybibitem{Wad90} @tab Philip Wadler. Deforestation: transforming programs to eliminate trees. Theoretical Computer Science, 73(2): 231--248, June 1990. @url{https://doi.org/10.1016/0304-3975%2890%2990147-A}

@end multitable

@c ------------------------------------------------
@node Indices
@unnumbered Indices
@c ------------------------------------------------

@c @node Concept Index
@c @unnumbered Concept Index
@printindex cp
@c @node Function Index
@c @unnumbered Function Index
@c @printindex fn

@c \nocite{JLangReference,FalkoffIverson1968,Abrams1970,FalkoffIverson1973,FalkoffIverson1978,APLexamples1,ArraysCowan,KonaTheLanguage,blitz++2001}

@bye
