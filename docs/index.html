<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- newra (version 1, updated 2019 November 28)

(c) lloda 2017-2019

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. -->
<!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>newra —An alternative array library for Guile 3</title>

<meta name="description" content="newra —An alternative array library for Guile 3">
<meta name="keywords" content="newra —An alternative array library for Guile 3">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="#Top" rel="start" title="Top">
<link href="#Indices" rel="index" title="Indices">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<h1 class="settitle" align="center">newra —An alternative array library for Guile 3</h1>


















































<a name="Top"></a>
<div class="header">
<p>
Next: <a href="#Introduction" accesskey="n" rel="next">Introduction</a>, Up: <a href="dir.html#Top" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="newra"></a>
<h1 class="top"><code>newra</code></h1>

<p><code>newra</code> (version 1, updated 2019 November 28)
</p>
<p>(c) lloda 2017&ndash;2019
</p>
<div class="smalldisplay">
<pre class="smalldisplay">Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
</pre></div>


<p><code>newra</code> is a Scheme-only replacement for the built-in C-based array facility in Guile 2.2.
</p>
<p>This document uses ‘array’ to refer both to the old built-in array type and to the new type introduced in <code>newra</code>. The distinction is made as necessary.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Introduction" accesskey="1">Introduction</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Why Guile arrays need replacing.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Basic-use" accesskey="2">Basic use</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Arrays as data structures.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Advanced-use" accesskey="3">Advanced use</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Guile as an array language.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Hazards" accesskey="4">Hazards</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">User beware.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Reference" accesskey="5">Reference</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Systematic list of types and functions.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Sources" accesskey="6">Sources</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">It&rsquo;s been done before.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Indices" accesskey="7">Indices</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Or try the search function.
</td></tr>
</table>



<hr>
<a name="Introduction"></a>
<div class="header">
<p>
Next: <a href="#Basic-use" accesskey="n" rel="next">Basic use</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Introduction-1"></a>
<h2 class="chapter">1 Introduction</h2>

<p>A multidimensional array is a container (or rather a container view) whose elements can be looked up using a multi-index (i₀, i₁, ...). Each of the indices i₀, i₁, ... has a constant range [l₀, h₀], [l₁, h₁], ... independent of the values of the other indices, so the array is ‘rectangular’. The number of indices in the multi-index is the <em>rank</em> of the array, and the list ((l₀ h₀) (l₁ h₁) ... (lᵣ₋₁ hᵣ₋₁)) is the <em>shape</em> of the array. We speak of a rank-<em>r</em> array or of an <em>r</em>-array.
</p>
<p>Sometimes we deal with multidimensional <em>expressions</em> where the elements aren&rsquo;t stored anywhere, but are computed on demand when the expression is looked up. In this general sense, an ‘array’ is just a function of integers with a rectangular domain. Such an array would be immutable.
</p>
<p>Arrays (in the form of <em>matrices</em>, <em>vectors</em>, or <em>tensors</em>) are very common objects in math and programming, and it is very useful to be able to manipulate arrays as individual entities rather than as aggregates — that is one of the main purposes of <code>newra</code>.
</p>
<p>The rest of this section discusses the motivation for <code>newra</code> in more detail. To start using the library, please jump ahead to <a href="#Basic-use">Basic use</a>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Rank-polymorphism-and-rank-extension" accesskey="1">Rank polymorphism and rank extension</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-pieces-of-an-array" accesskey="2">The pieces of an array</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Built_002din-Guile-arrays" accesskey="3">Built-in Guile arrays</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Rank-polymorphism-and-rank-extension"></a>
<div class="header">
<p>
Next: <a href="#The-pieces-of-an-array" accesskey="n" rel="next">The pieces of an array</a>, Up: <a href="#Introduction" accesskey="u" rel="up">Introduction</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Rank-polymorphism-and-rank-extension-1"></a>
<h3 class="section">1.1 Rank polymorphism and rank extension</h3>

<a name="index-rank-polymorphism"></a>
<p><em>Rank polymorphism</em> is the ability to treat an array of rank <em>r</em> as an array of lower rank where the elements are themselves arrays.
</p>
<a name="index-cell"></a>
<a name="index-frame"></a>
<p>Think of a matrix A, a 2-array with sizes (n₀, n₁) where the elements A(i₀, i₁) are numbers. If we consider the subarrays (rows) A(0, ...), A(1, ...), ..., A(n₀-1, ...) as individual elements, then we have a new view of A as a 1-array of size n₀ with those rows as elements. We say that the rows A(i₀)≡A(i₀, ...) are the 1-<em>cells</em> of A, and the numbers A(i₀, i₁) are 0-cells of A. For an array of arbitrary rank <em>r</em> the (<em>r</em>-1)-cells of A are called its <em>items</em>. The prefix of the shape (n₀, n₁, ... nₙ₋₁₋ₖ) that is not taken up by the k-cell is called the k-<em>frame</em>.
</p>
<p>An obvious way to store an array in linearly addressed memory is to place its items one after another. So we would store a 3-array as
</p>
<blockquote>
<p>A: [A(0), A(1), ...]
</p></blockquote>

<p>and the items of A(i₀), etc. are in turn stored in the same way, so
</p>
<blockquote>
<p>A: [A(0): [A(0, 0), A(0, 1) ...], ...]
</p></blockquote>

<p>and the same for the items of A(i₀, i₁), etc.
</p>
<blockquote>
<p>A: [[A(0, 0): [A(0, 0, 0), A(0, 0, 1) ...], A(0, 1): [A(0, 1, 0), A(0, 1, 1) ...]], ...]
</p></blockquote>

<a name="index-order_002c-row_002dmajor"></a>
<p>This way to lay out an array in memory is called <em>row-major order</em> or <em>C-order</em>, since it&rsquo;s the default order for built-in arrays in C. A row-major array A with sizes (n₀, n₁, ... nᵣ₋₁) can be looked up like this:
</p>
<a name="x_002dstrides"></a><blockquote>
<p>A(i₀, i₁, ...) = (storage-of-A) [(((i₀n₁ + i₁)n₂ + i₂)n₃ + ...)+iᵣ₋₁] = (storage-of-A) [o + s₀i₀ + s₁i₁ +  ...]
</p></blockquote>

<p>where the numbers (s₀, s₁, ...) are called the <em>strides</em><a name="DOCF1" href="#FOOT1"><sup>1</sup></a>. Note that the ‘linear’ or ‘raveled’ address [o + s₀i₀ + s₁i₁ +  ...] is an affine function of (i₀, i₁, ...). If we represent an array as a tuple
</p>
<blockquote>
<p>A ≡ ((storage-of-A), o, (s₀, s₁, ...))
</p></blockquote>

<p>then any affine transformation of the indices can be achieved simply by modifying the numbers (o, (s₀, s₁, ...)), with no need to touch the storage. This includes very common operations such as: <a href="#x_002dra_002dtranspose">transposing</a> axes, <a href="#x_002dra_002dreverse">reversing</a> the order along an axis, most cases of <a href="#Slicing">slicing</a>, and sometimes even reshaping or tiling the array.
</p>
<p>A basic example is obtaining the i₀-th item of A:
</p>
<blockquote>
<p>A(i₀) ≡ ((storage-of-A), o+s₀i₀, (s₁, ...))
</p></blockquote>

<p>Note that we can iterate over these items by simply bumping the pointer o+s₀i₀. This means that iterating over (k&gt;0)-cells doesn&rsquo;t have to cost any more than iterating over 0-cells (<a href="#x_002dra_002dslice_002dfor_002deach"><code>ra-slice-for-each</code></a>).
</p>
<hr>
<a name="The-pieces-of-an-array"></a>
<div class="header">
<p>
Next: <a href="#Built_002din-Guile-arrays" accesskey="n" rel="next">Built-in Guile arrays</a>, Previous: <a href="#Rank-polymorphism-and-rank-extension" accesskey="p" rel="prev">Rank polymorphism and rank extension</a>, Up: <a href="#Introduction" accesskey="u" rel="up">Introduction</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-pieces-of-an-array-1"></a>
<h3 class="section">1.2 The pieces of an array</h3>

<p>An <code>newra</code> array is in fact an aggregate of the following pieces:
</p>
<a name="index-rank"></a>
<a name="index-dim-vector"></a>
<a name="index-root-vector"></a>
<ul>
<li> A <em>root vector</em>.
This can be a Scheme vector, as well as one of several other vector-like types.
</li><li> A <em>zero</em>.
An arbitary integer.
</li><li> A <em>dim vector</em>.
Each dim consists of a length (<em>len</em>), a lower bound (<em>lo</em>), and a <em>step</em>. The length of the dim vector is the <em>rank</em> of the array.
</li></ul>

<p>Together, the dim vector and the zero define an affine function of array indices <code>i₀, i₁, ..</code> that produces an index into the root vector (or root for short). Thus, the array is simply a multidimensional view of the root.
</p>
<p>For example, the following pieces
</p>
<ul>
<li> root: v = <code>#(1 2 3 4 5 6 7)</code>
</li><li> zero: 1
</li><li> dims: <code>#(#&lt;&lt;dim&gt; len: 2 lo: 0 step: 2&gt; #&lt;&lt;dim&gt; len: 2 lo: 0 step: 1&gt;)</code>
</li></ul>

<p>define an array A(i₀, i₁) = v(1 + 2·i₀ + 1·i₁), 0≤i₀&lt;2, 0≤i₁&lt;2, that is A = [[2 3] [4 5]].
</p>
<p>In <code>newra</code> code,
</p>
<div class="example">
<pre class="verbatim">(make-ra-root (vector 1 2 3 4 5 6 7) 1 (vector (make-dim 2 0 2) (make-dim 2 0 1)))
</pre><pre class="example">&rArr; <code>#%2:2:2((2 3) (4 5))</code>
</pre></div>

<p>The default print style means <code>#%RANK:LEN₀:LEN₁(...)</code>.
</p>
<p>It&rsquo;s unusual to need to specify the dims directly. More commonly, one creates an array of whatever size
</p>
<pre class="verbatim">&gt; (define a (make-ra #f 3 4))
&gt; a
</pre><p>&rArr; <code>#%2:3:4((#f #f #f #f) (#f #f #f #f) (#f #f #f #f))</code>
</p>
<p>which automatically creates a root of the required size, so that all the array elements are distinct. Then one operates on the array without making reference to the underlying root,
</p>
<pre class="verbatim">&gt; (ra-set! a 99 2 2)
</pre><p>&rArr; <code>#%2:3:4((#f #f #f #f) (#f #f 99 #f) (#f #f #f #f))</code>
</p>
<p>Still, since the array is just a view of the root, any changes on the array are reflected there as well
</p>
<pre class="verbatim">&gt; (ra-root a)
</pre><p>&rArr; <code>#(#f #f #f #f #f #f #f #f #f #f 99 #f)</code>
</p>
<p>and the other way around,
</p>
<pre class="verbatim">&gt; (define b (make-ra-root (vector 'x) 0 (vector (make-dim 3 0 0) (make-dim 2 0 0))))
&gt; b
</pre><p>&rArr; <code>#%2:3:2((x x) (x x) (x x))</code>
</p>
<pre class="verbatim">&gt; (vector-set! (ra-root b) 0 'Z)
&gt; b
</pre><p>&rArr; <code>#%2:3:2((Z Z) (Z Z) (Z Z))</code>
</p>
<hr>
<a name="Built_002din-Guile-arrays"></a>
<div class="header">
<p>
Previous: <a href="#The-pieces-of-an-array" accesskey="p" rel="prev">The pieces of an array</a>, Up: <a href="#Introduction" accesskey="u" rel="up">Introduction</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Built_002din-Guile-arrays-1"></a>
<h3 class="section">1.3 Built-in Guile arrays</h3>

<p>Dense multidimensional arrays work similarly in every language that offers them, and built-in Guile arrays are no different —they also have a root (<code>shared-array-root</code>), a zero (computable from <code>shared-array-offset</code> and <code>array-shape</code>), and a dim vector (<code>array-shape</code>, <code>shared-array-increments</code>). Functionally, they are entirely equivalent to the objects offered by <code>newra</code>. Why replace them, then?
</p>
<a name="index-libguile"></a>
<p>Built-in Guile arrays are implemented in C, as part of libguile. As a Guile type they have their own low-level type tag, and all the basic array operations are C stubs, even the most basic functions such as <code>array-ref</code> or <code>array-rank</code>. Obtaining any of the components of the array requires calling into C. There are several problems with this.
</p>
<p>First, the built-in library offers a single function to manipulate array dims, <code>make-shared-array</code>. Although this is a sufficient interface, it is excessively generic, and also very cumbersome and inefficient. The array dims cannot be manipulated directly from Scheme, so any alternative interface written in Scheme is forced to go through <code>make-shared-array</code>.
</p>
<p>Second, the C stubs create a barrier to optimization by the Scheme compiler. The main loop of an operation such as <code>(array-map! c + a b)</code> has to be implemented in C (for the reasons given above) and then it has to call back to Scheme on each iteration in order to apply <code>+</code>. Since the Scheme compiler doesn&rsquo;t have any special support for <code>array-map!</code>, it doesn&rsquo;t know what the types of the arguments are, etc. and those checks and dispatches are repeated over and over. <a name="DOCF2" href="#FOOT2"><sup>2</sup></a>
</p>
<p>Third, the larger functions of the array interface, such as <code>array-map!</code>, etc. are not interruptible. This is especially inconvenient when operating on large arrays.
</p>
<p>These problems are solved if the built-in type is replaced with a new type defined in Scheme.
</p>
<hr>
<a name="Basic-use"></a>
<div class="header">
<p>
Next: <a href="#Advanced-use" accesskey="n" rel="next">Advanced use</a>, Previous: <a href="#Introduction" accesskey="p" rel="prev">Introduction</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Basic-use-1"></a>
<h2 class="chapter">2 Basic use</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Creating-and-accessing-arrays" accesskey="1">Creating and accessing arrays</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Special-arrays" accesskey="2">Special arrays</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Iteration" accesskey="3">Iteration</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Slicing" accesskey="4">Slicing</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Reshaping-and-resizing" accesskey="5">Reshaping and resizing</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Other-operations-on-arrays" accesskey="6">Other operations on arrays</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Foreign-interface" accesskey="7">Foreign interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Compatibility-with-old-Guile-arrays" accesskey="8">Compatibility with old Guile arrays</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Creating-and-accessing-arrays"></a>
<div class="header">
<p>
Next: <a href="#Special-arrays" accesskey="n" rel="next">Special arrays</a>, Up: <a href="#Basic-use" accesskey="u" rel="up">Basic use</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Creating-and-accessing-arrays-1"></a>
<h3 class="section">2.1 Creating and accessing arrays</h3>

<p>An array can be created anew (<a href="#x_002dmake_002dra_002dnew"><code>make-ra-new</code></a>), or over an existing root (<a href="#x_002dmake_002dra_002droot"><code>make-ra-root</code></a>). <a href="#x_002dc_002ddims"><code>c-dims</code></a> can be used to compute the dim vector.
</p>
<div class="example">
<pre class="verbatim">(make-ra-new #t 'x (vector (make-dim 3 0 2) (make-dim 2 0 1))) ; more simply
(make-ra-new #t 'x (c-dims 3 2))
</pre><pre class="example">&rArr; #%2:3:2((x x) (x x) (x x))
</pre></div>

<div class="example">
<pre class="verbatim">(make-ra-new 'f32 0.0 (c-dims 3 2))
</pre><pre class="example">&rArr; #%2f32:3:2((0.0 0.0) (0.0 0.0) (0.0 0.0))
</pre></div>

<p>An existing root implies the type, so it doesn&rsquo;t need to be given.
</p>
<div class="example">
<pre class="verbatim">(make-ra-root (vector 1 2 3 4 5 6) (c-dims 3 2))
</pre><pre class="example">&rArr; #%2:3:2((1 2) (3 4) (5 6))
</pre></div>

<p><a href="#x_002dmake_002dra"><code>make-ra</code></a> or <a href="#x_002dmake_002dtyped_002dra"><code>make-typed-ra</code></a> use <code>c-dims</code> by default.
</p>
<div class="example">
<pre class="verbatim">(make-ra 99 2 3)
</pre><pre class="example">&rArr; #%2:3:2((9 9) (9 9) (9 9))
</pre></div>

<div class="example">
<pre class="verbatim">(make-typed-ra 'f64 99 2 3)
</pre><pre class="example">&rArr; #%2f64:3:2((9.0 9.0) (9.0 9.0) (9.0 9.0))
</pre></div>

<p><code>newra</code> arrays are applicative; to look up an element of an array, use it as a function of the indices.
</p>
<div class="example">
<pre class="verbatim">(define a (make-ra #f 3 2))
(set! (a 0 0) 9)
(set! (a 1 1) 3)
</pre><pre class="example">&rArr; #%2:3:4((9 #f) (#f 3) (#f #f))
</pre><pre class="verbatim">(a 0 0)
</pre><pre class="example">&rArr; 9
</pre></div>

<a name="index-prefix-slice"></a>
<p>If you give fewer indices than the rank, you get a prefix slice. This slice shares the root of the original array.
</p>
<div class="example">
<pre class="verbatim">(a 1)
</pre><pre class="example">&rArr; #%1:2(#f 3)
</pre><pre class="verbatim">(set! ((a 1) 0) 'b)
</pre><pre class="example">&rArr; #%1:2(b 3)
</pre><pre class="verbatim">a
</pre><pre class="example">&rArr; #%2:3:4((9 #f) (b 3) (#f #f))
</pre></div>

<p>You can also access arrays in the more usual way with the functions <a href="#x_002dra_002dref"><code>ra-ref</code></a> and <a href="#x_002dra_002dset_0021"><code>ra-set!</code></a>. See <a href="#Slicing">Slicing</a> for additional options.
</p>
<hr>
<a name="Special-arrays"></a>
<div class="header">
<p>
Next: <a href="#Iteration" accesskey="n" rel="next">Iteration</a>, Previous: <a href="#Creating-and-accessing-arrays" accesskey="p" rel="prev">Creating and accessing arrays</a>, Up: <a href="#Basic-use" accesskey="u" rel="up">Basic use</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Special-arrays-1"></a>
<h3 class="section">2.2 Special arrays</h3>

<p>Any type that is usable as the root of an old built-in Guile array is also usable as root of a <code>newra</code> array. These include
</p>
<ul>
<li> vectors (e.g. <code>(vector 3)</code>)
</li><li> SRFI-4 typed vectors (e.g. <code>(c64vector 1 2+0i)</code>)
</li><li> strings (e.g. <code>&quot;hello&quot;</code>)
</li><li> bitvectors (e.g. <code>(bitvector #f #t #f #t)</code>)
</li></ul>

<p><code>newra</code> supports an additional root vector type, <code>&lt;aseq&gt;</code>, representing an infinite arithmetic sequence.
</p>
<a name="index-make_002daseq"></a>
<a name="x_002dnone"></a><dl>
<dt><a name="index-make_002daseq-1"></a>function<!-- /@w -->: <strong>make-aseq</strong> <em>[org [inc]]</em></dt>
<dd>
<p>Create an arithmetic sequence [<code>org, org+inc, org+2·inc, ...</code>]. The default values of <code>org</code> and <code>inc</code> are respectively 0 and 1. For example:
</p>
<div class="example">
<pre class="verbatim">(make-ra-root (make-aseq 0 3) (vector (make-dim 10)) 0)
</pre><pre class="example">&rArr; #%1d:10(0 3 6 9 12 15 18 21 24 27)
</pre></div>

<p>(The example above can be written <code>(<a href="#x_002dra_002diota">ra-iota</a> 10 0 3)</code>).
</p></dd></dl>

<p><code>aseq</code> roots are immutable. The type tag of <code>aseq</code> roots is <code>d</code>. Arrays with integer-valued <code>aseq</code> roots have a few special uses; one of them is as arguments in <a href="#Slicing">slicing</a>.
</p>
<a name="index-infinite-axes"></a>
<p>To make <code>&lt;aseq&gt;</code> even more useful, <code>newra</code> supports axes with infinite length.
</p>
<div class="example">
<pre class="verbatim">(ra-ref (make-ra-root (make-aseq) (vector (make-dim #f)) 0) #e1e12) ; or more simply
(ra-ref (ra-iota) #e1e12)
</pre><pre class="example">&rArr; 1000000000000
</pre></div>

<p>These are treated especially when used in iteration, in that they match axes of any finite length (<a href="#x_002dra_002dmap_0021"><code>ra-map!</code></a>). Effectively this lets one use <code>(<a href="#x_002dra_002dtranspose"><code>ra-transpose</code></a> (ra-iota) k)</code> as a placeholder for the index over axis <code>k</code>.
</p>
<div class="example">
<pre class="verbatim">(ra-map! (make-ra 0 3) + (ra-iota 3) (ra-iota))
</pre><pre class="example">&rArr; #1%3(0 2 4)
</pre></div>

<a name="index-dead-axes"></a>
<a name="x_002ddead_002daxes"></a><p><code>newra</code> also supports &lsquo;dead axes&rsquo;, which are simply axes whose step is 0. These axes can have any length although effectively only one position (the lower bound, by default 0) is ever accessed. Some functions work purely by creating dead axes.
</p>
<div class="example">
<pre class="verbatim">(define A (make-ra-root #(1 2 3) (c-dims 3)))
(ra-tile A 2 2)
</pre><pre class="example">&rArr; #%3d:2:2:3(((0 1 2) (0 1 2)) ((0 1 2) (0 1 2)))
</pre><pre class="verbatim">(ra-dims (ra-tile A 2 2))
</pre><pre class="example">&rArr; #(#&lt;&lt;dim&gt; len: 2 lo: 0 step: 0&gt; #&lt;&lt;dim&gt; len: 2 lo: 0 step: 0&gt; #&lt;&lt;dim&gt; len: 3 lo: 0 step: 1&gt;)
</pre></div>

<a name="index-singleton-axis"></a>
<p>When an axis has 0 step and infinite length, it operates essentially as ‘singleton axes’ operate in other array languages. The main diference is that the ability to match any finite length is explicit; an axis with length 1 will still fail to match an axis with length 2 (say).
</p>
<hr>
<a name="Iteration"></a>
<div class="header">
<p>
Next: <a href="#Slicing" accesskey="n" rel="next">Slicing</a>, Previous: <a href="#Special-arrays" accesskey="p" rel="prev">Special arrays</a>, Up: <a href="#Basic-use" accesskey="u" rel="up">Basic use</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Iteration-1"></a>
<h3 class="section">2.3 Iteration</h3>

<p>The basic array iteration operations in <code>newra</code> all operate by effect. This gives you control of how the result is allocated. If one of the arguments is designated as destination, as is the case with <a href="#x_002dra_002dmap_0021"><code>ra-map!</code></a>, then that is the result of the whole iteration. For example:
</p>
<div class="example">
<pre class="verbatim">(ra-map! (make-ra #f 3) - (ra-iota 3 1))
</pre><pre class="example">&rArr; #%1:3(-1 -2 -3)
</pre></div>

<p>It is common to need the indices of the elements during array iteration. <code>newra</code> iteration operations do not keep track of those indices<a name="DOCF3" href="#FOOT3"><sup>3</sup></a> because it isn&rsquo;t free to do so. You need to pass the indices you need as arguments, but it&rsquo;s easy to do so by using an infinite index vector together with <a href="#x_002dra_002dtranspose"><code>ra-transpose</code></a>.
</p>
<div class="example">
<pre class="verbatim">(define i0 (ra-iota))
(define i1 (ra-transpose (ra-iota) 1))
(ra-map! (make-ra #f 2 2) list (list-&gt;ra 2 '((A B) (C D))) i0 i1)
</pre><pre class="example">&rArr; #%2:2:2(((A 0 0) (B 0 1)) ((C 1 0) (D 1 1)))
</pre></div>

<p>One can iterate not only over the whole array, but also over any <code>n</code>-frame (the first <code>n</code> axes of an array), using <a href="#x_002dra_002dslice_002dfor_002deach"><code>ra-slice-for-each</code></a>. In this case the operation takes array slices as arguments, even when they are of rank 0; this allows writing to any of the arguments. When there are several arrays involved, all the frames must match.
</p>
<p>In the following example, <code>xys</code> is of rank 2, <code>angle</code> is of rank 1, and their first axes have the same length.
</p>
<div class="example">
<pre class="verbatim">(ra-slice-for-each 1
  (lambda (xy angle)
; inside the op, xy is rank 1, angle is rank 0
    (ra-set! angle (atan (ra-ref xy 1) (ra-ref xy 0))))
  xys angles)
</pre></div>

<a name="index-prefix-matching"></a>
<p>The iteration procedures in <code>newra</code> all perform rank extension of their arguments through prefix matching (see <a href="#Rank-polymorphism-and-rank-extension">Rank polymorphism and rank extension</a>). In the following example, the shapes of the arguments are (5 5), (5) and (<code>#f</code> 5), so the common prefixes (5), (5) and (<code>#f</code>) all match.
</p>
<div class="example">
<pre class="verbatim">(ra-map! (make-ra 5 5) * (ra-iota 5 1) (ra-transpose (ra-iota 5 1) 1))
</pre><pre class="example">&rArr; <code>#%2:5:5((1 2 3 4 5) (2 4 6 8 10) (3 6 9 12 15) (4 8 12 16 20) (5 10 15 20 25))</code>
</pre></div>

<p>Another example using <a href="#x_002dra_002dcopy_0021">ra-copy!</a>,
</p>
<div class="example">
<pre class="verbatim">(ra-copy! (list-&gt;ra 2 '((a b) (p q) (x y)))
          (list-&gt;ra 1 '(1 2 3)))
</pre><pre class="example">&rArr; <code>#%2:3:2((1 1) (2 2) (3 3))</code>
</pre></div>

<hr>
<a name="Slicing"></a>
<div class="header">
<p>
Next: <a href="#Reshaping-and-resizing" accesskey="n" rel="next">Reshaping and resizing</a>, Previous: <a href="#Iteration" accesskey="p" rel="prev">Iteration</a>, Up: <a href="#Basic-use" accesskey="u" rel="up">Basic use</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Slicing-1"></a>
<h3 class="section">2.4 Slicing</h3>

<p>Slicing refers to the operation of taking a partial view of an array (e.g. a row or a column out of a matrix) through modification of the dim vector. This can be done with creative uses of <a href="#x_002dra_002dravel"><code>ra-ravel</code></a>, <a href="#x_002dra_002dreshape"><code>ra-reshape</code></a> and <a href="#x_002dra_002dtranspose"><code>ra-transpose</code></a>, and of course by direct modification of the dim vector, but the facilities described in this section are usually a lot clearer.
</p>
<a name="index-prefix-slice-1"></a>
<p>The simplest form of slicing uses <a href="#x_002dra_002dslice">ra-slice</a> to produce ‘prefix slices’.
</p>
<div class="example">
<pre class="verbatim">(define a (list-&gt;ra 3 '(((a b) (x y)) ((A B) (X Y)))))
</pre><pre class="example">&rArr; <code>#%3:2:2:2(((a b) (x y)) ((A B) (X Y)))</code>
</pre><pre class="verbatim">(ra-slice a 0 1 0)
</pre><pre class="example">&rArr; <code>#%0(x)</code>
</pre><pre class="verbatim">(ra-slice a 0 1)
</pre><pre class="example">&rArr; <code>#%1:2(x y)</code>
</pre><pre class="verbatim">(ra-slice a 0)
</pre><pre class="example">&rArr; <code>#%2:2:2((a b) (x y))</code>
</pre><pre class="verbatim">(ra-slice a)
</pre><pre class="example">&rArr; <code>#%3:2:2:2(((a b) (x y)) ((A B) (X Y)))</code>
</pre></div>

<p>The prefix slice always shares the root of the source array, so it can be used to modify the source array.
</p>
<div class="example">
<pre class="verbatim">(ra-fill! (ra-slice a 1 0) '99)
</pre><pre class="example">&rArr; <code>#%1:2(99 99)</code>
</pre><pre class="verbatim">a
</pre><pre class="example">&rArr; <code>#%3:2:2:2(((a b) (x y)) ((99 99) (X Y)))</code>
</pre></div>

<p>The variant <a href="#x_002dra_002dcell"><code>ra-cell</code></a> is identical to <code>ra-slice</code> except that it returns an element (and not a rank 0 array) when the full set of indices is given.
</p>
<div class="example">
<pre class="verbatim">(ra-slice a 0 1 0)
</pre><pre class="example">&rArr; <code>x</code>
</pre></div>

<p><code>ra-cell</code> is a <a href="#Rank-polymorphism-and-rank-extension">rank-polymorphic</a> generalization of the basic element lookup function <a href="#x_002dra_002dref"><code>ra-ref</code></a>, which requires the full set of indices.
</p>
<div class="example">
<pre class="verbatim">(ra-ref a 0 1 0) ; same as ra-cell
</pre><pre class="example">&rArr; <code>x</code>
</pre><pre class="verbatim">(ra-ref a 0 1)
</pre><pre class="example">&rArr; <code>&quot;&lt;unnamed port&gt;&quot;:...: Throw to key `bad-number-of-indices' with args `(3 2)'.</code>
</pre></div>

<p>Both <code>ra-cell</code> and <code>ra-slice</code> (and <code>ra-ref</code>) take scalar indices as arguments. The more powerful function <a href="#x_002dra_002dfrom"><code>ra-from</code></a> is able to handle arrays of indices.
</p>
<a name="index-_007b_002c-from"></a>
<blockquote>
<pre class="verbatim">(ra-from a i₀ ...) ⇒ b
</pre></blockquote>

<p>Each of the <code>i₀...</code> is either 1. an integer; 2. an array of integers; 3. the special value #t. Integer arguments contain indices into the respective axis of <code>a</code>. <code>#t</code> for <code>iₖ</code> is a shortcut for <code>(let ((d (vector-ref (ra-dims a) k))) (ra-iota (dim-len d) (dim-lo d)))</code>, or in human speech ‘the whole of axis <code>k</code>’. The result <code>b</code> has rank equal to the sum of all the ranks of the <code>i₀...</code>, and is defined as
</p>
<blockquote>
<pre class="verbatim">(ra-ref b j₀ ...) = (ra-ref a (ra-ref i₀ j₀ ...) ...)
</pre></blockquote>

<p>In other words, <code>ra-from</code> produces the outer product of the indices <code>i₀...</code> with operator <code>a</code> (if one thinks of <code>(a i₀ ...)</code> as <code>(ra-ref a i₀ ...)</code>).
</p>
<p>If all of the <code>i...</code> are integers or arrays of type <code>d</code> (such as those produced by <code>ra-iota</code> or <code>ra-i</code>) then the result of <code>ra-from</code> shares the root of <code>a</code>. Otherwise <code>newra</code> cannot tell whether the indices are an arithmetic sequence, so the result has to be copied to a new root. For example:
</p>
<div class="example">
<pre class="verbatim">(define a (list-&gt;ra 2 '((a b c) (d e f))))
</pre><pre class="example">&rArr; <code>#%2:2:3((a b c) (d e f))</code>
</pre><pre class="verbatim">(ra-from a 0 #t) ; row 0, will share root
</pre><pre class="example">&rArr; <code>#%1:3(a b c)</code>
</pre><pre class="verbatim">(ra-from a #t 1) ; column 1, will share root
</pre><pre class="example">&rArr; <code>#%1:2(b e)</code>
</pre><pre class="verbatim">(ra-from a #t (make-ra-root #(2 0))) ; cols 2 &amp; 0, won't share root
</pre><pre class="example">&rArr; <code>#%2:2:2((c a) (f d))</code>
</pre><pre class="verbatim">(ra-from a #t (ra-iota 2 2 -2)) ; cols 2 &amp; 0, will share root
</pre><pre class="example">&rArr; <code>#%2:2:2((c a) (f d))</code>
</pre></div>

<p>One may give fewer <code>i</code> than the rank of <code>a</code>. The missing arguments are taken as <code>#t</code> (see <a href="#Rank-polymorphism-and-rank-extension">Rank polymorphism and rank extension</a>).
</p>
<div class="example">
<pre class="verbatim">(ra-from a 0) ; row 0, same as (ra-from a 0 #t)
</pre><pre class="example">&rArr; <code>#%1d:3(0 1 2)</code>
</pre></div>

<a name="index-ldots"></a>
<p>When used as an argument to <code>ra-from</code> (or <code>ra-amend!</code>), the special object <code>(<a href="#x_002dldots">ldots</a> n)</code> stands for <code>n</code> times <code>#t</code>. <code>(ldots)</code> alone will expand to fill the rank of the array argument, so the indices that come after are pushed to the last axes.
</p>
<div class="example">
<pre class="verbatim">(ra-from A 0 (ldots 1) 1) ; same as (ra-from A 0 #t 1)
(ra-from B 0 (ldots 2) 1) ; same as (ra-from B 0 #t #t 1)
(ra-from C 0 (ldots) 1) ; same as (ra-from C 1 (ldots (- (ra-rank C) 2)) 1)
</pre></div>

<p>For instance:
</p><div class="example">
<pre class="verbatim">(ra-i 4 3 2)
</pre><pre class="example">&rArr; #%3d:4:3:2(((0 1) (2 3) (4 5)) ((6 7) (8 9) (10 11)) ((12 13) (14 15) (16 17)) ((18 19) (20 21) (22 23)))
</pre><pre class="verbatim">(ra-from (ra-i 4 3 2) (ldots) 1) ; select second element on last axis
</pre><pre class="example">&rArr; #%2d:4:3((1 3 5) (7 9 11) (13 15 17) (19 21 23))
</pre></div>

<p>When it is known that the result of <code>ra-from</code> will share the root with its argument, that can be used to modify the original array. For example:
</p>
<div class="example">
<pre class="verbatim">(ra-fill! (ra-from a 1) x)
</pre><pre class="example">&rArr; <code>#%2:3((a b c) (x x x)</code>
</pre><pre class="verbatim">a
</pre><pre class="example">&rArr; <code>#%2:3((a b c) (x x x))</code>
</pre></div>

<p><a href="#x_002dra_002damend_0021"><code>ra-amend!</code></a> handles the general case:
</p>
<div class="example">
<pre class="verbatim">(define a (list-&gt;ra 2 '((a b c) (d e f))))
(ra-amend! a 'Y #t (make-ra-root #(2 0)))
</pre><pre class="example">&rArr; <code>#%2:3((Y b Y) (Y e Y))</code>
</pre><pre class="verbatim">a
</pre><pre class="example">&rArr; <code>#%2:3((Y b Y) (Y e Y))</code>
</pre></div>
<p>while on the other hand
</p><div class="example">
<pre class="verbatim">(define a (list-&gt;ra 2 '((a b c) (d e f))))
(ra-fill! (ra-from a #t (make-ra-root #(2 0))) 'Y)
</pre><pre class="example">&rArr; <code>#%2:3((Y Y) (Y Y))</code>
</pre><pre class="verbatim">a
</pre><pre class="example">&rArr; <code>#%2:3((a b c) (d e f))</code>
</pre></div>

<hr>
<a name="Reshaping-and-resizing"></a>
<div class="header">
<p>
Next: <a href="#Other-operations-on-arrays" accesskey="n" rel="next">Other operations on arrays</a>, Previous: <a href="#Slicing" accesskey="p" rel="prev">Slicing</a>, Up: <a href="#Basic-use" accesskey="u" rel="up">Basic use</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Reshaping-and-resizing-1"></a>
<h3 class="section">2.5 Reshaping and resizing</h3>

<a name="index-APL"></a>
<a name="index-_002c_002c-ravel"></a>
<a name="index-_005b_003f_005d_002c-reshape"></a>
<p>To match APL dyadic ρ, <code>newra</code> offers a set of three different functions.
</p>
<p><a href="#x_002dra_002dreshape"><code>ra-reshape</code></a> and <a href="#x_002dra_002dravel"><code>ra-ravel</code></a> are in a way the inverse of each other, and neither is able to increase the size of the array. For that purpose <a href="#x_002dra_002dtile"><code>ra-tile</code></a> is provided.
</p>
<div class="example">
<pre class="verbatim">(ra-dimensions (ra-i 2 3 4))
</pre><pre class="example">&rArr; (2 3 4)
</pre><pre class="verbatim">(ra-dimensions (ra-tile (ra-i 2 3 4) 5))
</pre><pre class="example">&rArr; (5 2 3 4)
</pre><pre class="verbatim">(ra-dimensions (ra-ravel (ra-tile (ra-i 2 3 4) 5) 2))
</pre><pre class="example">&rArr; (10 3 4)
</pre><pre class="verbatim">(ra-dimensions (ra-reshape (ra-ravel (ra-tile (ra-i 2 3 4) 5) 2) 2 5))
</pre><pre class="example">&rArr; (2 5 3 4)
</pre></div>

<p><code>ra-reshape</code> and <code>ra-tile</code> always reuse the root of the argument. On the other hand <code>ra-ravel</code> may not be able to — this is one of the reasons to have three different functions instead of only one. You can check in advance whether <code>ra-ravel</code> will reuse the root with the function <a href="#x_002dra_002dorder_002dc_003f"><code>ra-order-c?</code></a>.
</p>
<p>All three functions <code>ra-reshape</code>, <code>ra-ravel</code>, and <code>ra-tile</code> operate on prefix axes. To operate on other axes, use <a href="#x_002dra_002dtranspose"><code>ra-transpose</code></a>.
</p>
<hr>
<a name="Other-operations-on-arrays"></a>
<div class="header">
<p>
Next: <a href="#Foreign-interface" accesskey="n" rel="next">Foreign interface</a>, Previous: <a href="#Reshaping-and-resizing" accesskey="p" rel="prev">Reshaping and resizing</a>, Up: <a href="#Basic-use" accesskey="u" rel="up">Basic use</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Other-operations-on-arrays-1"></a>
<h3 class="section">2.6 Other operations on arrays</h3>

<a name="index-_005b_003f_005d_002c-transpose"></a>
<a name="index-transpose"></a>
<p>The most important operation on arrays, other than selection and iteration, is transposition.
</p>
<p><a href="#x_002dra_002dtranspose"><code>ra-transpose</code></a> takes a source array and a list of axis arguments. These axis arguments correspond to the axes of the source array; the values of the arguments are the corresponding axes of the result array.
</p>
<div class="example">
<pre class="verbatim">(ra-dimensions (ra-transpose (ra-i 10 20 30) 2 0 1))
</pre><pre class="example">&rArr; <code>'(20 30 10)</code>
</pre></div>

<p>That is, axis 0 in the source array is mapped to axis 2 in the destination array, axis 1 to axis 0, and axis 2 to axis 1. The result array always shares the root of the source array.
</p>
<p>As you&rsquo;d expect
</p>
<div class="example">
<pre class="verbatim">(ra-transpose (ra-i 2 3) 1 0)
</pre><pre class="example">&rArr; <code>#%2d:3:2((0 3) (1 4) (2 5))</code>
</pre></div>

<p>One can map more than one axis of the source array to the same axis of the destination array. In that case the step of the destination axis becomes the sum of the steps of all the source axes. The classic example is
</p>
<a name="index-diagonal"></a>
<div class="example">
<pre class="verbatim">(define A (ra-copy #t (ra-i 3 3)))
(ra-fill! (ra-transpose A 0 0) 'x)
A
</pre><pre class="example">&rArr; <code>#%2:3:3((x 1 2) (3 x 5) (6 7 x))</code>
</pre></div>

<p>If one doesn&rsquo;t give values for all the source axes, the missing axes are sent beyond the highest one that was given. These are equivalent:
</p>
<div class="example">
<pre class="verbatim">(ra-transpose (ra-i 2 3 4) 1 0 2)
(ra-transpose (ra-i 2 3 4) 1 0)
</pre></div>

<p>as are these:
</p>
<div class="example">
<pre class="verbatim">(ra-transpose (ra-i 2 3) 1)
(ra-transpose (ra-i 2 3) 1 2)
</pre></div>

<p>Note that in the last example there is no source axis for destination axis 0. Destination axes not mentioned in the axis argument list become <a href="#x_002ddead_002daxes">dead axes</a>. The rank of the result array is always just large enough to fit all the destination axes.
</p>
<div class="example">
<pre class="verbatim">(ra-dimensions (ra-transpose (ra-i 2 3) 1))
</pre><pre class="example">&rArr; (#f 2 3)
</pre></div>

<p>In particular, <code>(ra-transpose A)</code> is equivalent to <code>(ra-transpose A 0 1 ... (- (ra-rank A) 1))</code> (which is of course the same array as <code>A</code>).
</p>
<a name="index-index-placeholder"></a>
<p>This can be exploited to create ‘index placeholders’, e.g.
</p><div class="example">
<pre class="verbatim">(define (tensor-index i) (ra-transpose (ra-iota) i))
(ra-for-each (compose display list) (make-ra #f 3 4) (tensor-index 0) (tensor-index 1))
</pre><pre class="example">&rArr; <code>(#f 0 0)(#f 0 1)(#f 0 2)(#f 0 3)(#f 1 0)(#f 1 1)(#f 1 2)(#f 1 3)(#f 2 0)(#f 2 1)(#f 2 2)(#f 2 3)</code>
</pre></div>

<a name="index-_005b_003f_005d"></a>
<a name="index-grade"></a>
<p>The function <a href="#x_002dra_002duntranspose"><code>ra-untranspose</code></a> takes its axis arguments the other way from <code>ra-transpose</code>; the values of the arguments are the axes of the original array and the position in the argument list are the axes of the result array. This is less flexible than <code>ra-transpose</code>, but can be used to reverse an application of <code>ra-transpose</code> without having to sort (‘grade’) the original axis arguments.
</p>
<div class="example">
<pre class="verbatim">(define a (ra-i 2 3 4))
(ra-equal? a (ra-untranspose (ra-transpose a 2 0 1) 2 0 1))
</pre><pre class="example">&rArr; <code>#t</code>
</pre></div>




<hr>
<a name="Foreign-interface"></a>
<div class="header">
<p>
Next: <a href="#Compatibility-with-old-Guile-arrays" accesskey="n" rel="next">Compatibility with old Guile arrays</a>, Previous: <a href="#Other-operations-on-arrays" accesskey="p" rel="prev">Other operations on arrays</a>, Up: <a href="#Basic-use" accesskey="u" rel="up">Basic use</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Foreign-interface-1"></a>
<h3 class="section">2.7 Foreign interface</h3>

<p>One of the major reasons to use arrays instead of other Scheme data structures is that they let one pass a large amount of data through a C interface very efficiently. The data doesn&rsquo;t need to be copied — one only needs to pass a pointer to the data, plus the sizes and the strides in some order. C doesn&rsquo;t have a standard consolidated array type, so the particulars are variable. In any case, the required items can be obtained trivially from a <code>newra</code> array object.
</p>
<p>For example:
</p>
<hr>
<a name="Compatibility-with-old-Guile-arrays"></a>
<div class="header">
<p>
Previous: <a href="#Foreign-interface" accesskey="p" rel="prev">Foreign interface</a>, Up: <a href="#Basic-use" accesskey="u" rel="up">Basic use</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Compatibility-with-old-Guile-arrays-1"></a>
<h3 class="section">2.8 Compatibility with old Guile arrays</h3>

<p>The functions <a href="#x_002dra_002d_003earray"><code>ra-&gt;array</code></a> and <a href="#x_002darray_002d_003era"><code>array-&gt;ra</code></a> are provided to convert to and from <code>newra</code> arrays and built-in Guile arrays. It is an error to use <code>ra-&gt;array</code> on arrays whose root isn&rsquo;t supported by the built-in arrays, or that have an infinite length. Except in those two cases, the conversion is transparent both ways, and the result always shares the root of the argument.
</p>
<div class="example">
<pre class="verbatim">(define a (make-array 'o 2 3))
(define b (array-&gt;ra a))
(ra-set! b 'x 1 1)
(array-set! a 'y 0 2)
a
</pre><pre class="example">&rArr; <code>#2((o o y) (o x o))</code>
</pre><pre class="verbatim">b
</pre><pre class="example">&rArr;  <code>#%2((o o y) (o x o))</code>
</pre></div>

<p><code>&lt;aseq&gt;</code>-root arrays must be type converted before using <code>ra-&gt;array</code>.
</p>
<div class="example">
<pre class="verbatim">(ra-&gt;array (ra-copy #t (ra-i 2 3)))
</pre><pre class="example">&rArr; #2((0 1 2) (3 4 5))
</pre></div>

<p>On dead axes, infinite lengths can be set to 1 (with <a href="#x_002dra_002dsingletonize"><code>ra-singletonize</code></a>) to allow conversion with <code>ra-&gt;array</code> or to other array systems that do singleton broadcasting.
</p>
<div class="example">
<pre class="verbatim">(define a (ra-transpose (ra-i 2 3) 1 3))
a
</pre><pre class="example">&rArr; <code>#%4d:d:2:d:3((((0 1 2)) ((3 4 5))))</code>
</pre><pre class="verbatim">(ra-singletonize a)
</pre><pre class="example">&rArr; <code>#%4d:1:2:1:3((((0 1 2)) ((3 4 5))))</code>
</pre></div>

<p>One important difference between the built-in array functions and <code>newra</code> is that bounds matching in <code>newra</code> is strict: finite bounds must be identical for axes to match, while for <code>array-map!</code>, <code>array-for-each</code>, <code>array-copy!</code>, etc. the iteration range is the intersection of the ranges of the arguments<a name="DOCF4" href="#FOOT4"><sup>4</sup></a>. <code>newra</code> provides <a href="#x_002dra_002dclip"><code>ra-clip</code></a> to match ranges easily.
</p>
<div class="example">
<pre class="verbatim">(define a (make-ra-root (vector 'a 'b 'c 'd 'e 'f 'g))) ; range is 0..6
(define b (ra-reshape (ra-iota 4) '(2 5))) ; range is 2..5
(ra-copy! a b)
</pre><pre class="example">&rArr; <code>Throw to key `mismatched-lens' with args `(7 4 at-dim 0)'.</code>
</pre><pre class="verbatim">(ra-copy! (ra-clip a b) b)
a
</pre><pre class="example">&rArr; <code>#%1:7(a b 0 1 2 3 g)</code>
</pre></div>





<hr>
<a name="Advanced-use"></a>
<div class="header">
<p>
Next: <a href="#Hazards" accesskey="n" rel="next">Hazards</a>, Previous: <a href="#Basic-use" accesskey="p" rel="prev">Basic use</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Advanced-use-1"></a>
<h2 class="chapter">3 Advanced use</h2>

<p>NOTE This section is about a facility that hasn&rsquo;t been implemented yet.
</p>
<p>In array languages such as APL, scalar operations are implicitly extended to work on arrays, so one can just write (the equivalent of) <code>(+ A B)</code> instead of <code>(ra-map! (make-ra ...) + A B)</code>. The basic <code>newra</code> iteration operations such as <code>ra-map!</code> already perform rank extension of their arguments (so <code>A</code> or <code>B</code> can have a different rank from the result, as long as the prefix axes match). We still need ways to:
</p>
<ul>
<li> associate an operation to the ranks of their arguments, so that the right frame of iteration can be chosen.
</li><li> compute the shape and type of the result (if any).
</li><li> handle scalar (non-array) arguments.
</li></ul>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Verbs" accesskey="1">Verbs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Reductions" accesskey="2">Reductions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Verbs"></a>
<div class="header">
<p>
Next: <a href="#Reductions" accesskey="n" rel="next">Reductions</a>, Up: <a href="#Advanced-use" accesskey="u" rel="up">Advanced use</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Verbs-1"></a>
<h3 class="section">3.1 Verbs</h3>

<hr>
<a name="Reductions"></a>
<div class="header">
<p>
Previous: <a href="#Verbs" accesskey="p" rel="prev">Verbs</a>, Up: <a href="#Advanced-use" accesskey="u" rel="up">Advanced use</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Reductions-1"></a>
<h3 class="section">3.2 Reductions</h3>

<hr>
<a name="Hazards"></a>
<div class="header">
<p>
Next: <a href="#Reference" accesskey="n" rel="next">Reference</a>, Previous: <a href="#Advanced-use" accesskey="p" rel="prev">Advanced use</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Hazards-1"></a>
<h2 class="chapter">4 Hazards</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Differences-with_002e_002e_002e" accesskey="1">Differences with...</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Common-mistakes" accesskey="2">Common mistakes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Performance-pitfalls" accesskey="3">Performance pitfalls</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Differences-with_002e_002e_002e"></a>
<div class="header">
<p>
Next: <a href="#Common-mistakes" accesskey="n" rel="next">Common mistakes</a>, Up: <a href="#Hazards" accesskey="u" rel="up">Hazards</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Differences-with_002e_002e_002e-1"></a>
<h3 class="section">4.1 Differences with...</h3>

<p>If you come to <code>newra</code> from another array language or library, you may want to be aware of some of these differences.
</p>
<p>Differences with builtin Guile arrays:
</p>
<a name="index-APL-1"></a>
<p>Differences with APL:
</p><ul>
<li> The default base index in <code>newra</code> is 0, as in <code>⎕io←0</code>. The base index isn&rsquo;t global, but it may be different per axis.
</li><li> <code>newra</code> arrays of size 1 are not equivalent to scalars and always retain their rank. For example, <code>(make-ra 99)</code>, <code>(make-ra 99 1)</code> and <code>(make-ra 99 1 1)</code> are all different from each other and from the scalar <code>99</code>, while in APL <code>99</code>, <code>(1 ⍴ 99)</code>, and <code>(1 1 ⍴ 99)</code> are all the same thing.
</li><li> When a function takes multiple arguments, the meaning with multiple arguments is an extension of the meaning with a single argument. This contrasts with APL where the monadic and dyadic versions of a verb usually have a related but independent definition. For example <code>(ra-transpose a)</code>≡<code>(ra-transpose a 0)</code>≡<code>(ra-transpose a 0 1)</code>, but (assuming <code>a</code> is of rank 2) <code>⍉a</code>≡<code>2 1⍉a</code>. Please check the documentation for each function.
</li></ul>

<a name="index-Fortran"></a>
<p>Differences with Fortran:
</p><ul>
<li> The default base index in <code>newra</code> is 0, not 1. Like in Fortran, the base index may be different for each axis of each array.
</li><li> Unlike Fortran, the default element order in arrays is row-major, or ‘last index changes fastest’. It&rsquo;s possible to define and manipulate arrays in any other order, including Fortran&rsquo;s default. However, some functions (such as <code>ra-ravel</code>) only support row-major order.
</li><li> <code>newra</code> uses prefix matching for rank extension on arguments on any rank, while Fortran only performs rank extension on scalar arguments.
</li></ul>

<a name="index-NumPy"></a>
<p>Differences with NumPy:
</p><ul>
<li> <code>newra</code> uses prefix matching for rank extension, while Numpy uses suffix matching. For example: FIXME.
</li><li> <code>newra</code> doesn&rsquo;t use singleton broadcasting. Axes of length 1 only match axes of length 1. For example, <code>(ra-map! (make-ra 0 2) + (make-ra 90 1) (make-ra 7 2))</code> is an error because the shapes (2), (1), (2) don&rsquo;t agree.
</li></ul>

<a name="index-Octave"></a>
<a name="index-Matlab"></a>
<p>Differences with Octave:
</p><ul>
<li> The default base index in <code>newra</code> is 0, not 1. It&rsquo;s possible to have base indices be 1 on particular arrays (or particular axes of an array), but not globally.
</li><li> In Octave, any array of rank ≤ 2 is implicity a matrix (an array of rank 2). This isn&rsquo;t true in <code>newra</code>, so, for example, an array of rank 1 isn&rsquo;t equivalent to an array of rank 2 with a single row (a ‘row vector’).
</li><li> Unlike Octave, the default element order in arrays is row-major, or ‘last index changes fastest’. It&rsquo;s possible to define and manipulate arrays in any other order, including Octave&rsquo;s default. However, some functions (such as <code>ra-ravel</code>) only support row-major order.
</li><li> <code>newra</code> uses prefix matching for rank extension on arguments on any rank, while Octave only performs rank extension on scalar arguments.
</li></ul>

<hr>
<a name="Common-mistakes"></a>
<div class="header">
<p>
Next: <a href="#Performance-pitfalls" accesskey="n" rel="next">Performance pitfalls</a>, Previous: <a href="#Differences-with_002e_002e_002e" accesskey="p" rel="prev">Differences with...</a>, Up: <a href="#Hazards" accesskey="u" rel="up">Hazards</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Common-mistakes-1"></a>
<h3 class="section">4.2 Common mistakes</h3>

<hr>
<a name="Performance-pitfalls"></a>
<div class="header">
<p>
Previous: <a href="#Common-mistakes" accesskey="p" rel="prev">Common mistakes</a>, Up: <a href="#Hazards" accesskey="u" rel="up">Hazards</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Performance-pitfalls-1"></a>
<h3 class="section">4.3 Performance pitfalls</h3>

<hr>
<a name="Reference"></a>
<div class="header">
<p>
Next: <a href="#Sources" accesskey="n" rel="next">Sources</a>, Previous: <a href="#Hazards" accesskey="p" rel="prev">Hazards</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Reference-1"></a>
<h2 class="chapter">5 Reference</h2>

<a name="index-make_002dra_002dnew"></a>
<a name="x_002dmake_002dra_002dnew"></a><dl>
<dt><a name="index-make_002dra_002dnew-1"></a>function<!-- /@w -->: <strong>make-ra-new</strong> <em>type value dims</em></dt>
<dd><p>Create an array over a new root of the given <var>type</var> and the necessary size (according to <var>dims</var>), and fill it with <var>value</var>.
</p><div class="example">
<pre class="verbatim">(make-ra-new 'u8 0 (c-dims 3 2))
</pre><pre class="example">&rArr; #%2u8:3:2((0 0) (0 0) (0 0))
</pre></div>
</dd></dl>

<a name="index-make_002dra_002droot"></a>
<a name="x_002dmake_002dra_002droot"></a><dl>
<dt><a name="index-make_002dra_002droot-1"></a>function<!-- /@w -->: <strong>make-ra-root</strong> <em>root [dims [zero]]</em></dt>
<dd><p>Create an array over the given <var>root</var>.
</p><div class="example">
<pre class="verbatim">(make-ra-root (vector 1 2 3))
</pre><pre class="example">&rArr; #%1d:3(1 2 3)
</pre></div>

<div class="example">
<pre class="verbatim">(make-ra-root (vector 1 2 3) (vector (make-dim 2)))
</pre><pre class="example">&rArr; #%1d:2(1 2)
</pre></div>

<div class="example">
<pre class="verbatim">(make-ra-root (vector 1 2 3) (vector (make-dim 2)) 1)
</pre><pre class="example">&rArr; #%1d:2(2 3)
</pre></div>
</dd></dl>

<a name="index-make_002dra"></a>
<a name="x_002dmake_002dra"></a><dl>
<dt><a name="index-make_002dra-1"></a>function<!-- /@w -->: <strong>make-ra</strong> <em>val bounds ...</em></dt>
</dl>

<a name="index-make_002dtyped_002dra"></a>
<a name="x_002dmake_002dtyped_002dra"></a><dl>
<dt><a name="index-make_002dtyped_002dra-1"></a>function<!-- /@w -->: <strong>make-typed-ra</strong> <em>type val bounds ...</em></dt>
</dl>

<a name="index-c_002ddims"></a>
<a name="x_002dc_002ddims"></a><dl>
<dt><a name="index-c_002ddims-1"></a>function<!-- /@w -->: <strong>c-dims</strong> <em>bounds ...</em></dt>
<dd>
<p>Create dims for C-order array (packed elements, last dimension changing fastest).
</p>
<p>Each of the bounds may be an integer (a length) or a pair of integers (lower and upper bounds).
</p><div class="example">
<pre class="verbatim">(c-dims 2 3)
</pre><pre class="example">&rArr; #(#&lt;&lt;dim&gt; len: 2 lo: 0 step: 3&gt; #&lt;&lt;dim&gt; len: 3 lo: 0 step: 1&gt;)
</pre></div>
</dd></dl>

<a name="index-ra_002diota"></a>
<a name="x_002dra_002diota"></a><dl>
<dt><a name="index-ra_002diota-1"></a>function<!-- /@w -->: <strong>ra-iota</strong> <em>[len [lo [step]]]</em></dt>
<dd>
<p>Create rank-1 index array. The root is of type <code>&lt;aseq&gt;</code>.
</p>
<div class="example">
<pre class="verbatim">(ra-iota 4 3 -1)
</pre><pre class="example">&rArr; #%1d:4(3 2 1 0)
</pre></div>
</dd></dl>

<a name="index-ra_002di"></a>
<a name="x_002dra_002di"></a><dl>
<dt><a name="index-ra_002di-1"></a>function<!-- /@w -->: <strong>ra-i</strong> <em>len ...</em></dt>
<dd>
<p>Create multidimensional index array with the given lengths. The root is of type <code>&lt;aseq&gt;</code>.
</p>
<div class="example">
<pre class="verbatim">(ra-i 2 3 4)
</pre><pre class="example">&rArr; #%3d:2:3:4(((0 1 2 3) (4 5 6 7) (8 9 10 11)) ((12 13 14 15) (16 17 18 19) (20 21 22 23)))
</pre></div>
</dd></dl>

<a name="index-ra_002dravel"></a>
<a name="x_002dra_002dravel"></a><dl>
<dt><a name="index-ra_002dravel-1"></a>function<!-- /@w -->: <strong>ra-ravel</strong> <em>a [n]</em></dt>
<dd><p>Ravel the first <var>n</var> axes of array <var>a</var> to C order, the whole array by default.
</p><div class="example">
<pre class="verbatim">(ra-ravel (ra-i 2 3))
</pre><pre class="example">&rArr; #%1d:6(0 1 2 3 4 5)
</pre></div>
</dd></dl>

<a name="index-ra_002dreshape"></a>
<a name="x_002dra_002dreshape"></a><dl>
<dt><a name="index-ra_002dreshape-1"></a>function<!-- /@w -->: <strong>ra-reshape</strong> <em>a bounds ...</em></dt>
<dd><p>Reshape the first axis of array <var>a</var> to <var>bounds</var>.
</p>
<p>Each of the bounds may be an integer (a length) or a pair of integers (lower and upper bounds).
</p><div class="example">
<pre class="verbatim">(ra-reshape (ra-i 4 3) 2 2)
</pre><pre class="example">&rArr; #%1d:2:2:3(((0 1 2) (3 4 5)) ((6 7 8) (9 10 11)))
</pre></div>
</dd></dl>

<a name="index-ra_002dtile"></a>
<a name="x_002dra_002dtile"></a><dl>
<dt><a name="index-ra_002dtile-1"></a>function<!-- /@w -->: <strong>ra-tile</strong> <em>a bounds ...</em></dt>
<dd><p>Repeat array <var>a</var> by prepending axes with the given <var>bounds</var>.
</p>
<p>Each of the bounds may be an integer (a length) or a pair of integers (lower and upper bounds).
</p><div class="example">
<pre class="verbatim">(ra-tile (ra-i 3) 2)
</pre><pre class="example">&rArr; #%1d:2:3((0 1 2) (0 1 2))
</pre></div>
</dd></dl>

<a name="index-ra_002dtranspose"></a>
<a name="x_002dra_002dtranspose"></a><dl>
<dt><a name="index-ra_002dtranspose-1"></a>function<!-- /@w -->: <strong>ra-transpose</strong> <em>a axes ...</em></dt>
<dd><p>Transpose each axis 0, 1, ... of <var>a</var> to matching destination <var>axes</var>.
</p>
<p>The transposed array has the same root as <var>a</var>.
</p><div class="example">
<pre class="verbatim">(ra-transpose (ra-i 2 3) 1 0)
</pre><pre class="example">&rArr; #%1d:3:2((0 3) (1 4) (2 5))
</pre></div>
</dd></dl>

<a name="index-ra_002duntranspose"></a>
<a name="x_002dra_002duntranspose"></a><dl>
<dt><a name="index-ra_002duntranspose-1"></a>function<!-- /@w -->: <strong>ra-untranspose</strong> <em>a axes ...</em></dt>
<dd><p>Transpose <var>axes</var> of <var>a</var> to matching destination axes 0, 1, ...
</p>
<p>The transposed array has the same root as <var>a</var>.
</p><div class="example">
<pre class="verbatim">(ra-untranspose (ra-transpose (ra-i 2 3 4) 2 1 0) 2 1 0)
</pre><pre class="example">&rArr; <code>#%3d:2:3:4(((0 1 2 3) (4 5 6 7) (8 9 10 11)) ((12 13 14 15) (16 17 18 19) (20 21 22 23)))</code>
</pre></div>

<p>but
</p>
<div class="example">
<pre class="verbatim">(ra-transpose (ra-transpose (ra-i 2 3 4) 2 1 0) 2 1 0)
</pre><pre class="example">&rArr; <code>#%3d:4:2:3(((0 4 8) (12 16 20)) ((1 5 9) (13 17 21)) ((2 6 10) (14 18 22)) ((3 7 11) (15 19 23)))</code>
</pre></div>
</dd></dl>

<a name="index-_005b_003f_005d_002c-reverse"></a>
<a name="index-ra_002dreverse"></a>
<a name="x_002dra_002dreverse"></a><dl>
<dt><a name="index-ra_002dreverse-1"></a>function<!-- /@w -->: <strong>ra-reverse</strong> <em>a axes ...</em></dt>
<dd><p>Reverse the given <var>axes</var> of <var>a</var>.
</p>
<p>The reversed array has the same root as <var>a</var>.
</p><div class="example">
<pre class="verbatim">(ra-reverse (ra-i 2 3) 0 1)
</pre><pre class="example">&rArr; #%1d:2:3((5 4 3) (2 1 0))
</pre></div>
</dd></dl>

<a name="index-_005b_003f_005d_002c-rotate"></a>
<a name="index-_005b_003f_005d_002c-rowel"></a>
<a name="index-ra_002drotate"></a>
<a name="x_002dra_002drotate"></a><dl>
<dt><a name="index-ra_002drotate-1"></a>function<!-- /@w -->: <strong>ra-rotate</strong> <em>a n</em></dt>
<dd><p>(FIXME: not implemented) Rotate the first axis of <var>a</var> <var>n</var> times. <var>n</var> may be any integer. The result has the type of <var>a</var>, unless that type is <code>d</code>, in which case the result is of type <code>#t</code>.
</p>
<p>Example:
</p><div class="example">
<pre class="verbatim">(ra-rotate (ra-i 3 2) -1)
</pre><pre class="example">&rArr; #%1:3:2((2 3) (4 5) (0 1))
</pre></div>
</dd></dl>

<a name="index-ra_002dindex_002dmap_0021"></a>
<a name="x_002dra_002dindex_002dmap_0021"></a><dl>
<dt><a name="index-ra_002dindex_002dmap_0021-1"></a>function<!-- /@w -->: <strong>ra-index-map!</strong> <em>a op</em></dt>
<dd><p>Iterate over array <var>a</var>, and to each element assign the result of <code>(op i₀ ...)</code>, where <code>i₀ ...</code> are the indices of that element.
</p></dd></dl>

<a name="index-ra_002dslice_002dfor_002deach"></a>
<a name="x_002dra_002dslice_002dfor_002deach"></a><dl>
<dt><a name="index-ra_002dslice_002dfor_002deach-1"></a>function<!-- /@w -->: <strong>ra-slice-for-each</strong> <em>k op a ...</em></dt>
<dd><p>Iterate over the <var>k</var>-frames of arrays <var>a</var> ..., applying <var>op</var> to the respective slices. The arguments <var>a</var> ... must have matching dimensions over their <var>k</var>-frames.
</p></dd></dl>

<p>Note that it isn&rsquo;t necessary for arguments <var>a</var> to have rank ≥ <var>k</var>. For example:
</p>
<div class="example">
<pre class="verbatim">(ra-slice-for-each 1
  (lambda (a b) (display (list (a) (b))))
  (make-ra-root #(a b))
  (ra-i 2 3))
</pre><pre class="example">&rArr; <code>(a #%1d:3(0 1 2))(b #%1d:3(3 4 5))</code>
</pre></div>

<div class="example">
<pre class="verbatim">(ra-slice-for-each 2
  (lambda (a b) (display (list (a) (b))))
  (make-ra-root #(a b))
  (ra-i 2 3))
</pre><pre class="example">&rArr; <code>(a 0)(a 1)(a 2)(b 3)(b 4)(b 5)</code>
</pre></div>

<a name="index-ra_002dmap_0021"></a>
<a name="x_002dra_002dmap_0021"></a><dl>
<dt><a name="index-ra_002dmap_0021-1"></a>function<!-- /@w -->: <strong>ra-map!</strong> <em>dst op a ...</em></dt>
<dd><p>Iterate over arrays <var>dst</var> <var>a</var> ... applying <var>op</var> to the respective elements in <var>a</var>, and storing the result in the respective element of <var>dst</var>. The arguments must have matching dimensions and the type of <var>dst</var> must be compatible with the results of <var>op</var>.
</p></dd></dl>

<p>This is equivalent to
</p><pre class="verbatim">(apply ra-slice-for-each
       (rank dst)
       (lambda (dst . a)
         (ra-set! dst (apply op (map ra-ref a))))
       dst a)
</pre>
<a name="index-ra_002dcopy_0021"></a>
<a name="x_002dra_002dcopy_0021"></a><dl>
<dt><a name="index-ra_002dcopy_0021-1"></a>function<!-- /@w -->: <strong>ra-copy!</strong> <em>dst src</em></dt>
<dd><p>Copy <var>src</var> to <var>dst</var>. The arguments must have matching dimensions and be of compatible types.
</p></dd></dl>

<p>For valid arguments, this is equivalent to any one of
</p><pre class="verbatim">(ra-map! dst identity src)
(ra-amend! dst src)
</pre>
<a name="index-ra_002dfill_0021"></a>
<a name="x_002dra_002dfill_0021"></a><dl>
<dt><a name="index-ra_002dfill_0021-1"></a>function<!-- /@w -->: <strong>ra-fill!</strong> <em>dst value</em></dt>
<dd><p>Assign <var>value</var> to each element of <var>dst</var>. The arguments must be of compatible types.
</p></dd></dl>

<p>This is equivalent to any one of
</p><div class="example">
<pre class="verbatim">(ra-map! dst (const value))
(ra-copy! dst (make-ra value))
(ra-amend! dst (make-ra value))
(ra-amend! dst value) ; as long as value isn't an array
</pre></div>

<p>Compare
</p>
<div class="example">
<pre class="verbatim">(ra-fill! (make-ra #f 2 2) (make-ra 'x))
</pre><pre class="example">&rArr; #%2:2:2((#%0(x) #%0(x)) (#%0(x) #%0(x)))
</pre><pre class="verbatim">(ra-amend! (make-ra #f 2 2) 'x)
</pre><pre class="example">&rArr; #%2:2:2((x x) (x x))
</pre><pre class="verbatim">(ra-amend! (make-ra #f 2 2) (make-ra 'x))
</pre><pre class="example">&rArr; #%2:2:2((x x) (x x))
</pre><pre class="verbatim">(ra-amend! (make-ra #f 2 2) (make-ra (make-ra 'x)))
</pre><pre class="example">&rArr; #%2:2:2((#%0(x) #%0(x)) (#%0(x) #%0(x)))
</pre></div>

<a name="index-ra_002dorder_002dc_003f"></a>
<a name="x_002dra_002dorder_002dc_003f"></a><dl>
<dt><a name="index-ra_002dorder_002dc_003f-1"></a>function<!-- /@w -->: <strong>ra-order-c?</strong> <em>a [n]</em></dt>
<dd><p>Check whether the first <var>n</var> axes of <var>ra</var> are in C-order. By default, check that the whole array is in C-order, and additionally that the step on the last axis is 1 (i.e. the array is ‘packed’).
</p></dd></dl>

<p><code>(ra-order-c? a n)</code> implies <code>(eq? (ra-root a) (ra-root (<a href="#x_002dra_002dravel"><code>ra-ravel</code></a> a n)))</code>. Note that the stronger condition <code>(ra-order-c? a)</code> is not necessary for <code>(eq? (ra-root a) (ra-root (ra-ravel a)))</code> to hold.
</p>
<a name="index-ra_002dref"></a>
<a name="x_002dra_002dref"></a><dl>
<dt><a name="index-ra_002dref-1"></a>function<!-- /@w -->: <strong>ra-ref</strong> <em>a i ...</em></dt>
</dl>

<a name="index-ra_002dset_0021"></a>
<a name="x_002dra_002dset_0021"></a><dl>
<dt><a name="index-ra_002dset_0021-1"></a>function<!-- /@w -->: <strong>ra-set!</strong> <em>a o i ...</em></dt>
</dl>

<a name="index-ra_002dslice"></a>
<a name="x_002dra_002dslice"></a><dl>
<dt><a name="index-ra_002dslice-1"></a>function<!-- /@w -->: <strong>ra-slice</strong> <em>a i ...</em></dt>
</dl>

<a name="index-ra_002dcell"></a>
<a name="x_002dra_002dcell"></a><dl>
<dt><a name="index-ra_002dcell-1"></a>function<!-- /@w -->: <strong>ra-cell</strong> <em>a i ...</em></dt>
</dl>

<a name="index-ra_002dfrom"></a>
<a name="x_002dra_002dfrom"></a><dl>
<dt><a name="index-ra_002dfrom-1"></a>function<!-- /@w -->: <strong>ra-from</strong> <em>a i ...</em></dt>
</dl>

<a name="index-ra_002damend_0021"></a>
<a name="x_002dra_002damend_0021"></a><dl>
<dt><a name="index-ra_002damend_0021-1"></a>function<!-- /@w -->: <strong>ra-amend!</strong> <em>a o i ...</em></dt>
</dl>

<a name="index-ldots-1"></a>
<a name="x_002dldots"></a><dl>
<dt><a name="index-ldots-2"></a>function<!-- /@w -->: <strong>ldots</strong> <em>[n] ...</em></dt>
<dd>
<p>Placeholder for <var>n</var> full axes, used as argument to <code>ra-from</code> or <code>ra-amend!</code>. Without <var>n</var>, expand to fill the rank of the argument <var>a</var> of <code>ra-from</code> or <code>ra-amend!</code>.
</p></dd></dl>

<a name="index-ra_002d_003earray"></a>
<a name="x_002dra_002d_003earray"></a><dl>
<dt><a name="index-ra_002d_003earray-1"></a>function<!-- /@w -->: <strong>ra-&gt;array</strong> <em>a</em></dt>
</dl>

<a name="index-array_002d_003era"></a>
<a name="x_002darray_002d_003era"></a><dl>
<dt><a name="index-array_002d_003era-1"></a>function<!-- /@w -->: <strong>array-&gt;ra</strong> <em>a</em></dt>
</dl>

<a name="index-ra_002dsingletonize"></a>
<a name="x_002dra_002dsingletonize"></a><dl>
<dt><a name="index-ra_002dsingletonize-1"></a>function<!-- /@w -->: <strong>ra-singletonize</strong> <em>a</em></dt>
</dl>

<a name="index-ra_002dclip"></a>
<a name="x_002dra_002dclip"></a><dl>
<dt><a name="index-ra_002dclip-1"></a>function<!-- /@w -->: <strong>ra-clip</strong> <em>a b</em></dt>
<dd><p>Slice <var>a</var> to the smaller of the bounds of <var>a</var> and <var>b</var>. <var>a</var> and <var>b</var> may have different ranks. In that case only the common prefix of <var>a</var> is sliced. The result always shares the root of <var>a</var>
</p></dd></dl>

<hr>
<a name="Sources"></a>
<div class="header">
<p>
Next: <a href="#Indices" accesskey="n" rel="next">Indices</a>, Previous: <a href="#Reference" accesskey="p" rel="prev">Reference</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sources-1"></a>
<h2 class="chapter">6 Sources</h2>

<table>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><a name="Abr70"></a>[Abr70]</td><td width="90%">Philip S. Abrams. An APL machine. Technical report SLAC-114 UC-32 (MISC), Stanford Linear Accelerator Center, Stanford University, Stanford, CA, USA, February 1970.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><a name="Ber87"></a>[Ber87]</td><td width="90%">Robert Bernecky. An introduction to function rank. ACM SIGAPL APL Quote Quad, 18(2):39–43, December 1987.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><a name="bli17"></a>[bli17]</td><td width="90%">The Blitz++ meta-template library. <a href="http://blitz.sourceforge.net">http://blitz.sourceforge.net</a>, November 2017.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><a name="Cha86"></a>[Cha86]</td><td width="90%">Gregory J. Chaitin. Physics in APL2, June 1986.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><a name="FI68"></a>[FI68]</td><td width="90%">Adin D. Falkoff and Kenneth Eugene Iverson. APL\360 User’s manual. IBM Thomas J. Watson Research Center, August 1968.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><a name="FI73"></a>[FI73]</td><td width="90%">Adin D. Falkoff and Kenneth Eugene Iverson. The design of APL. IBM Journal of Research and Development, 17(4):5–14, July 1973.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><a name="FI78"></a>[FI78]</td><td width="90%">Adin D. Falkoff and Kenneth Eugene Iverson. The evolution of APL. ACM SIGAPL APL, 9(1):30– 44, 1978.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><a name="J-S"></a>[J S]</td><td width="90%">J Primer. J Software, <a href="https://www.jsoftware.com/help/primer/contents.htm">https://www.jsoftware.com/help/primer/contents.htm</a>, November 2017.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><a name="Mat"></a>[Mat]</td><td width="90%">MathWorks. MATLAB documentation, <a href="https://www.mathworks.com/help/matlab/">https://www.mathworks.com/help/matlab/</a>, November 2017.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><a name="num17"></a>[num17]</td><td width="90%">NumPy. <a href="http://www.numpy.org">http://www.numpy.org</a>, November 2017.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><a name="Ric08"></a>[Ric08]</td><td width="90%">Henry Rich. J for C programmers, February 2008.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><a name="SSM14"></a>[SSM14]</td><td width="90%">Justin Slepak, Olin Shivers, and Panagiotis Manolios. An array-oriented language with static rank polymorphism. In Z. Shao, editor, ESOP 2014, LNCS 8410, pages 27–46, 2014.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><a name="Vel01"></a>[Vel01]</td><td width="90%">Todd Veldhuizen. Blitz++ user’s guide, February 2001.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><a name="Wad90"></a>[Wad90]</td><td width="90%">Philip Wadler. Deforestation: transforming programs to eliminate trees. Theoretical Computer Science, 73(2): 231&ndash;248, June 1990. <a href="https://doi.org/10.1016/0304-3975%2890%2990147-A">https://doi.org/10.1016/0304-3975%2890%2990147-A</a></td></tr>
</table>

<hr>
<a name="Indices"></a>
<div class="header">
<p>
Previous: <a href="#Sources" accesskey="p" rel="prev">Sources</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Indices-1"></a>
<h2 class="unnumbered">Indices</h2>

<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Indices_cp_symbol-1"><b>,</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_symbol-2"><b>{</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_symbol-3"><b>⊖</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_symbol-4"><b>⌽</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_symbol-5"><b>⍉</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_symbol-6"><b>⍋</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_symbol-7"><b>⍴</b></a>
 &nbsp; 
<br>
<a class="summary-letter" href="#Indices_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-T"><b>T</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-cp" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_symbol-1">,</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002c_002c-ravel"><code>,</code>, ravel</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reshaping-and-resizing">Reshaping and resizing</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_symbol-2">{</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007b_002c-from"><code>{</code>, from</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Slicing">Slicing</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_symbol-3">⊖</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005b_003f_005d_002c-rowel"><code>⊖</code>, rowel</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_symbol-4">⌽</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005b_003f_005d_002c-reverse"><code>⌽</code>, reverse</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005b_003f_005d_002c-rotate"><code>⌽</code>, rotate</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_symbol-5">⍉</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005b_003f_005d_002c-transpose"><code>⍉</code>, transpose</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-operations-on-arrays">Other operations on arrays</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_symbol-6">⍋</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005b_003f_005d">⍋</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-operations-on-arrays">Other operations on arrays</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_symbol-7">⍴</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005b_003f_005d_002c-reshape"><code>⍴</code>, reshape</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reshaping-and-resizing">Reshaping and resizing</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_letter-A">A</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-APL">APL</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reshaping-and-resizing">Reshaping and resizing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-APL-1">APL</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Differences-with_002e_002e_002e">Differences with...</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-array_002d_003era"><code>array-&gt;ra</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-c_002ddims"><code>c-dims</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cell">cell</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rank-polymorphism-and-rank-extension">Rank polymorphism and rank extension</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_letter-D">D</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-dead-axes">dead axes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-arrays">Special arrays</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-diagonal">diagonal</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-operations-on-arrays">Other operations on arrays</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dim-vector">dim vector</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-pieces-of-an-array">The pieces of an array</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Fortran">Fortran</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Differences-with_002e_002e_002e">Differences with...</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-frame">frame</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rank-polymorphism-and-rank-extension">Rank polymorphism and rank extension</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-grade">grade</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-operations-on-arrays">Other operations on arrays</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_letter-I">I</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-index-placeholder">index placeholder</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-operations-on-arrays">Other operations on arrays</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-infinite-axes">infinite axes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-arrays">Special arrays</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_letter-L">L</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-ldots"><code>ldots</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Slicing">Slicing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ldots-1"><code>ldots</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libguile">libguile</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002din-Guile-arrays">Built-in Guile arrays</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_letter-M">M</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-make_002daseq"><code>make-aseq</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-arrays">Special arrays</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-make_002dra"><code>make-ra</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-make_002dra_002dnew"><code>make-ra-new</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-make_002dra_002droot"><code>make-ra-root</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-make_002dtyped_002dra"><code>make-typed-ra</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Matlab">Matlab</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Differences-with_002e_002e_002e">Differences with...</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_letter-N">N</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-NumPy">NumPy</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Differences-with_002e_002e_002e">Differences with...</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_letter-O">O</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Octave">Octave</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Differences-with_002e_002e_002e">Differences with...</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-order_002c-row_002dmajor">order, row-major</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rank-polymorphism-and-rank-extension">Rank polymorphism and rank extension</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-prefix-matching">prefix matching</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Iteration">Iteration</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prefix-slice">prefix slice</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Creating-and-accessing-arrays">Creating and accessing arrays</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prefix-slice-1">prefix slice</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Slicing">Slicing</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_letter-R">R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002d_003earray"><code>ra-&gt;array</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002damend_0021"><code>ra-amend!</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dcell"><code>ra-cell</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dclip"><code>ra-clip</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dcopy_0021"><code>ra-copy!</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dfill_0021"><code>ra-fill!</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dfrom"><code>ra-from</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002di"><code>ra-i</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dindex_002dmap_0021"><code>ra-index-map!</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002diota"><code>ra-iota</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dmap_0021"><code>ra-map!</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dorder_002dc_003f"><code>ra-order-c?</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dravel"><code>ra-ravel</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dref"><code>ra-ref</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dreshape"><code>ra-reshape</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dreverse"><code>ra-reverse</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002drotate"><code>ra-rotate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dset_0021"><code>ra-set!</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dsingletonize"><code>ra-singletonize</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dslice"><code>ra-slice</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dslice_002dfor_002deach"><code>ra-slice-for-each</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dtile"><code>ra-tile</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002dtranspose"><code>ra-transpose</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ra_002duntranspose"><code>ra-untranspose</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rank">rank</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-pieces-of-an-array">The pieces of an array</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rank-polymorphism">rank polymorphism</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rank-polymorphism-and-rank-extension">Rank polymorphism and rank extension</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-root-vector">root vector</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-pieces-of-an-array">The pieces of an array</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_letter-S">S</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-singleton-axis">singleton axis</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-arrays">Special arrays</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Indices_cp_letter-T">T</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-transpose">transpose</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-operations-on-arrays">Other operations on arrays</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Indices_cp_symbol-1"><b>,</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_symbol-2"><b>{</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_symbol-3"><b>⊖</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_symbol-4"><b>⌽</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_symbol-5"><b>⍉</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_symbol-6"><b>⍋</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_symbol-7"><b>⍴</b></a>
 &nbsp; 
<br>
<a class="summary-letter" href="#Indices_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-T"><b>T</b></a>
 &nbsp; 
</td></tr></table>


<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h3><a name="FOOT1" href="#DOCF1">(1)</a></h3>
<p>Cf. <a href="https://en.wikipedia.org/wiki/Dope_vector"><em>dope vector</em></a></p>
<h3><a name="FOOT2" href="#DOCF2">(2)</a></h3>
<p>Guile used to offer dedicated operations to sum arrays, etc. but obviously that isn&rsquo;t any kind of solution.</p>
<h3><a name="FOOT3" href="#DOCF3">(3)</a></h3>
<p>Except for <a href="#x_002dra_002dindex_002dmap_0021"><code>ra-index-map!</code></a>, which is provided out of compatibility with the older array system.</p>
<h3><a name="FOOT4" href="#DOCF4">(4)</a></h3>
<p>I rejected this approach for <code>newra</code> because in my experience it results in errors going undetected much more often than it saves any work.</p>
</div>
<hr>



</body>
</html>
