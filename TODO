(newra) -*- mode: org; -*-

Help: [C-uc .] insert timestamp [C-cc] flip checkbox [C-uucc] partial flip checkbox [C-ct] flip TODO.

* TODO bugs [1/2]
  * [X] (call-with-input-string "#3()" read) vs (call-with-input-string "#%3()" read)
  * [ ] docstrings don't work for define-inlinable-case
  * [ ] zero lengths break ra-format

* TODO documentation [0/1]
  * [ ] actually explain rank extension / prefix matching in the manual

* TODO compatibility with existing Guile arrays [8/9]
  * [X] ra-slice-for-each ra-map! ra-for-each ra-cell ra-ref ra-set!
  * [X] ra-transpose ra-reverse
  * [X] make-ra make-ra-shared ra->list list->ra list->typed-ra
  * [X] ra-iota ra-i
  * [X] ra-index-map!
  * [X] ra-shape ra-dimensions
  * [X] ra-root ra-offset
  * [X] ra-equal?
  * [ ] root vectors are equivalent to rank-1 newra objects

* TODO whole array functions [8/15]
  * [X] ra-fold ra-fold*
  * [X] ra-any ra-every
  * [X] raw prefix matching
  * [X] generalized prefix matching
  * [-] high level slicing [3/4]
    - [X] ra-from
    - [X] ra-amend!
    - [X] (ldots)
    - [ ] axis insertion
  * [X] ra-ravel
    - [X] (ra-ravel a [n])
    - [X] (ra-order-c? a [n [org]])
    - [X] (ra-ravel a [n [org]])
  * [X] ra-tile [1/1]
    - [X] accept arbitrary axis
  * [X] ra-cat (ra-pcat, ra-scat)
    - [X] implementation
    - [X] tests
    - [X] tests with non-zero base indices
  * [-] ra-reshape [1/2]
    - [X] basic function
    - [ ] placeholder
    - [ ] accept arbitrary axis
  * [X] ra-clip
  * [ ] ra-grade
  * [-] ra-rotate [1/2]
    - [X] ra-rotate!
    - [ ] ra-rotate
  * [ ] as-ra
  * [ ] ra-filter, ra-select, etc.
  * [ ] ra-affine map that explicitly takes an [MÃ—(N+1)] matrix

* TODO misc array manipulation [0/1]
  * [ ] mapping of indices (beyond ra-reshape/ra-from). Maybe just explain in manual?

* TODO fundamental features [3/5]
  * [X] unsized index vectors
  * [X] tensor indices
  * [X] broadcasting
  * [ ] ways to control iteration (dim loop order, direction, etc.)
  * [ ] drag-along facility / lazy ops
    - [ ] verbs
    - [ ] rank conjunction
    - [ ] each (cf array-curry in srfi-179 or the old Guile array-enclose).
  * [ ] output types

* TODO performance [2/6]
  * [ ] u8 ra-fill! vs native (see bench.scm)
  * [ ] f64 ra-copy! vs native (see bench.scm)
  * [ ] ra-ref / ra-set! with 1 or 2 args vs built-in array-ref / array-set!
  * [ ] ra->list / list->ra vs built-in array->list / list->array. Maybe those can be reused?

* TODO friendlier undefined sizes [2/6]
  * [X] printing of 'd typed arrays
  * [X] printing with dead axes
  * [ ] reading of 'd typed arrays
  * [ ] printing with infinite axes
  * [ ] reading of arrays with inf axes
  * [ ] reading of arrays with dead axes

* TODO quality of life [2/10]
  * [X] rank-1 (or higher!) cases in the unrolled section (e.g. bytevector-copy!, bytevector-fill!).
  * [ ] rank-1 (or higher!) cases for generating functions (e.g. array->list).
  * [ ] the reverse of ra-singletonize, find a good name (see 'differences with numpy' in the doc).
  * [ ] make (set! (ra ...) o) work with slices just (ra ...).
  * [ ] refactor macros
  * [ ] bench tracking
  * [ ] move struct defs to (newra types)
  * [ ] parameters to control print format (eg print sizes/strides, truncate...)
    - [ ] CL/SRFI-163 style rank-0 (e.g. '#0 x' instead of '#0(x)').
    - [ ] print sizes in prefix
    - [ ] pretty-print
  * [X] pretty printer
    - [X] basic ra-format
    - [ ] compact mode
    - [ ] auto truncation

* TODO replace Guile arrays [0/5]
  * [ ] truncated-print support
  * [ ] equal? support
  * [ ] hooks into C / libguile
  * [ ] compilation of literals
  * [ ] replace all names
