(newra) -*- mode: org; -*-

Help: [C-uc .] insert timestamp [C-cc] flip checkbox [C-uucc] partial flip checkbox [C-ct] flip TODO.

* TODO bugs [5/8]
  * [X] (call-with-input-string "#3()" read) vs (call-with-input-string "#%3()" read)
  * [X] reader loses type when reading rank 0 arrays
  * [X] ra-equal? errors out with mismatched shapes
  * [X] zero lengths break ra-format
  * [X] (ra-dimensions (ra-iota))
  * [ ] ra-slice-for-each shouldn't return anything
  * [ ] (ra-from (list->ra 2 '((a b c) (x y z))) 1 1) => #%0(y) contradicts doc
  * [ ] docstrings don't work for define-inlinable-case

* TODO documentation [1/1]
  * [X] actually explain rank extension / prefix matching in the manual

* TODO compatibility with existing Guile arrays [8/9]
  * [X] ra-slice-for-each ra-map! ra-for-each ra-cell ra-ref ra-set!
  * [X] ra-transpose ra-reverse
  * [X] make-ra make-ra-shared ra->list list->ra list->typed-ra
  * [X] ra-iota ra-i
  * [X] ra-index-map!
  * [X] ra-shape ra-dimensions
  * [X] ra-root ra-offset
  * [X] ra-equal?
  * [ ] root vectors are equivalent to rank-1 newra objects
  * [ ] return roots for trivial rank-1 views on roots

* TODO whole array functions [8/15]
  * [X] ra-fold
  * [X] ra-any ra-every
  * [X] raw prefix matching
  * [X] generalized prefix matching
  * [-] high level slicing [3/4]
    - [X] ra-from
    - [X] ra-amend!
    - [X] (ldots)
    - [ ] axis insertion (?)
  * [X] ra-ravel
    - [X] (ra-ravel a [n])
    - [X] (ra-order-c? a [n [org]])
    - [X] (ra-ravel a [n [org]])
  * [X] ra-tile [2/2]
    - [X] accept arbitrary axis
    - [X] can produce dead axes
  * [X] ra-cat (ra-cat, ra-scat)
    - [X] implementation
    - [X] tests
    - [X] tests with non-zero base indices
  * [-] ra-reshape [2/3]
    - [X] basic function
    - [X] accept arbitrary axis
    - [ ] placeholder
  * [X] ra-clip
  * [ ] ra-grade
  * [-] ra-rotate [1/2]
    - [X] ra-rotate!
    - [ ] ra-rotate
  * [ ] as-ra
  * [ ] ra-filter, ra-select, etc.
  * [ ] ra-affine map that explicitly takes an [MÃ—(N+1)] matrix

* TODO misc array manipulation [0/1]
  * [ ] mapping of indices (beyond ra-reshape/ra-from). Maybe just explain in manual?

* TODO fundamental features [3/7]
  * [X] unsized index vectors
  * [X] tensor indices
  * [X] broadcasting
  * [ ] ways to control iteration (in order, dim loop order, direction, etc.)
  * [ ] a solution for (ra-amend! dst (RA-MAP OP (ra-from dst i ...)) i ...). Lenses?

* TODO ra the array language [/]
  * [ ] drag-along facility / lazy ops
    - [ ] verbs
    - [ ] rank conjunction
    - [ ] each (cf array-curry in srfi-179 or the old Guile array-enclose).
  * [ ] output types

* TODO performance [1/4]
  * [X] u8 ra-fill! vs native (see bench.scm) ok in 3.0.8 with partial bytevector-fill!
  * [ ] f64 ra-copy! vs native (see bench.scm)
  * [ ] ra-ref / ra-set! with 1 or 2 args vs built-in array-ref / array-set!
  * [ ] ra->list / list->ra vs built-in array->list / list->array. Maybe those can be reused?

* TODO friendlier undefined sizes [2/6]
  * [X] printing of 'd typed arrays
  * [X] printing with dead axes
  * [ ] reading of 'd typed arrays
  * [ ] printing with infinite axes
  * [ ] reading of arrays with inf axes
  * [ ] reading of arrays with dead axes

* TODO quality of life [2/9]
  * [X] rank-1 (or higher!) cases in the unrolled section (e.g. bytevector-copy!, bytevector-fill!).
  * [ ] rank-1 (or higher!) cases for generating functions (e.g. array->list).
  * [ ] the reverse of ra-singletonize, find a good name (see 'differences with numpy' in the doc).
  * [ ] make (set! (ra ...) o) work with slices just (ra ...).
  * [ ] refactor macros
  * [ ] bench tracking
  * [ ] move struct defs to (newra types)
  * [X] parameters to control print format (eg print sizes/strides, truncate...)
    - [X] CL/SRFI-163 style rank-0 (e.g. '#0 x' instead of '#0(x)').
    - [X] print sizes in prefix
    - [X] pretty-print
  * [-] pretty printer
    - [X] basic ra-format
    - [X] compact mode
    - [ ] handle unbounded axes
    - [ ] auto truncation

* TODO other [0/1]
  * [ ] review definition of (ra-untranspose a i ...). Does it make sense to allow any i < (rank a) ?

* TODO replace Guile arrays [0/5]
  * [ ] truncated-print support
  * [ ] equal? support
  * [ ] hooks into C / libguile
  * [ ] compilation of literals
  * [ ] replace all names
